This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-13T21:58:49.443Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
controls/
  DistrictPlanControls.tsx
  GinglesControl.tsx
  HeatMapControls.tsx
  InformationControl.tsx
dataVisuals/
  BoxplotComponent/
    AxisBottomCategoric.tsx
    AxisLeft.tsx
    BoxplotWrapper.tsx
    VerticalBox.tsx
  gingles/
    Gingles.tsx
    IncomeGingles.tsx
    NormalizedGingles.tsx
  BaseChart.tsx
  Boxplot.tsx
  ComparisonOverlay.tsx
  DistrictDetail.tsx
  Pie.tsx
  StateOverviewChart.tsx
  StateSummary.tsx
Main.tsx
MapLegend.tsx
Navbar.tsx
ui.tsx
USMap.tsx

================================================================
Repository Files
================================================================

================
File: controls/DistrictPlanControls.tsx
================
// DistrictPlanControls.tsx
import React, { useState } from 'react';
import {
  Box,
  HStack,
  Select,
  Button,
  Text
} from '@chakra-ui/react';

interface DistrictPlanControlsProps {
  onCompare: (planNumber: string) => void;
  state: string | null;
  isVisible: boolean;
}

const DistrictPlanControls: React.FC<DistrictPlanControlsProps> = ({
  onCompare,
  state,
  isVisible
}) => {
  const [selectedPlan, setSelectedPlan] = useState<string>('');

  if (!isVisible) return null;

  const handleCompareClick = () => {
    onCompare(selectedPlan);
  };

  return (
    <Box 
      position="absolute" 
      top="10px" 
      right="10px" 
      zIndex={1000}
      bg="white" 
      p={2} 
      borderRadius="md" 
      boxShadow="sm"
    >
      <HStack spacing={2}>
        <Select 
          size="sm"
          placeholder="Select plan"
          value={selectedPlan}
          onChange={(e) => setSelectedPlan(e.target.value)}
          width="150px"
        >
          <option value="1">Plan 1</option>
          <option value="2">Plan 2</option>
          <option value="3">Plan 3</option>
        </Select>
        <Button
          size="sm"
          colorScheme="blue"
          onClick={handleCompareClick}
          isDisabled={!selectedPlan}
        >
          Compare
        </Button>
      </HStack>
    </Box>
  );
};

export default DistrictPlanControls;

================
File: controls/GinglesControl.tsx
================
import { useState } from "react";
import { GingleMode } from "../../types/ChartDataItemInterface";
import { Box, Select } from "@chakra-ui/react";
import Gingles from "../dataVisuals/gingles/Gingles";
import IncomeGingles from "../dataVisuals/gingles/IncomeGingles";
import NormalizedGingles from "../dataVisuals/gingles/NormalizedGingles";

interface GinglesControlProps{
    selectedState: string
}

const GinglesControl = ({selectedState}: GinglesControlProps) => {
  const [mode, setMode] = useState<GingleMode>("Demographic");

  return (
    <Box>
      <Select onChange={(e) => setMode(e.target.value as GingleMode)}>
        {["Demographic", "Income", "Income/Race"].map((key) => {
          return (
            <option key={key} value={key}>
              {key}
            </option>
          );
        })}
      </Select>
      {
        mode == 'Demographic' ? <Gingles selectedState={selectedState}/> : mode == 'Income' ? <IncomeGingles selectedState={selectedState}/> : <NormalizedGingles selectedState={selectedState} />
      }
    </Box>
  );
};

export default GinglesControl;

================
File: controls/HeatMapControls.tsx
================
import React, { useState } from 'react';
import { 
  Menu, 
  MenuButton, 
  MenuList, 
  MenuItem, 
  Button, 
  Tooltip,
  HStack,
  Select,
  Box 
} from '@chakra-ui/react';
import { ChevronDownIcon } from '@chakra-ui/icons';

export type HeatmapType = 'none' | 'demographic' | 'poverty' | 'economic' | 'politicalincome';
export type DemographicGroup = 'white' | 'black' | 'hispanic' | 'asian';

interface HeatmapControlsProps {
  isEnabled: boolean;
  onHeatmapChange: (type: HeatmapType) => void;
  currentType: HeatmapType;
  onDemographicChange?: (group: DemographicGroup) => void;
}

const HeatmapControls: React.FC<HeatmapControlsProps> = ({
  isEnabled,
  onHeatmapChange,
  currentType,
  onDemographicChange
}) => {
  if (!isEnabled) return null;

  const getButtonText = () => {
    switch (currentType) {
      case 'none': return 'Show Heatmap';
      case 'demographic': return 'Demographic Heatmap';
      case 'poverty': return 'Poverty Heatmap';
      case 'economic': return 'Economic Heatmap';
      case 'politicalincome': return 'Political Income Heatmap';
      default: return 'Show Heatmap';
    }
  };

  return (
    <HStack spacing={2}>
      <Menu>
        <MenuButton
          as={Button}
          rightIcon={<ChevronDownIcon />}
          bg={currentType !== 'none' ? "#F7CFF2" : "white"}
          _hover={{ bg: "#F7CFF2" }}
        >
          {getButtonText()}
        </MenuButton>
        <MenuList>
        {currentType !== 'none' && (
            <MenuItem onClick={() => onHeatmapChange('none')}>
              Hide Heatmap
            </MenuItem>
          )}
          <MenuItem onClick={() => onHeatmapChange('demographic')}>
            Demographic Distribution
          </MenuItem>
          <MenuItem onClick={() => onHeatmapChange('poverty')}>
            Poverty Levels
          </MenuItem>
          <MenuItem onClick={() => onHeatmapChange('economic')}>
            Economic Indicators
          </MenuItem>
          <MenuItem onClick={() => onHeatmapChange('politicalincome')}>
            Political Income Distribution
          </MenuItem>
        </MenuList>
      </Menu>

      {currentType === 'demographic' && onDemographicChange && (
        <Select
          size="md"
          width="150px"
          bg="white"
          onChange={(e) => onDemographicChange(e.target.value as DemographicGroup)}
        >
          <option value="white">White</option>
          <option value="black">Black</option>
          <option value="hispanic">Hispanic</option>
          <option value="asian">Asian</option>
        </Select>
      )}
    </HStack>
  );
};

export default HeatmapControls;

================
File: controls/InformationControl.tsx
================
import { Box, Tab, TabList, Tabs } from "@chakra-ui/react";
import { VisualizationType } from "../../types/ChartDataItemInterface";
import CongressionalTable from "../dataVisuals/StateSummary";
import BaseChart from "../dataVisuals/BaseChart";

interface InformationControlProps {
  tabIndex: number;
  handleTabChange: (tabIndex: number) => void;
  selectedVisualization: VisualizationType;
  handleSelectDistrict: (district: number | null) => void;
  selectedState: string;
}

const InformationControl = ({
  tabIndex,
  handleTabChange,
  selectedVisualization,
  handleSelectDistrict,
  selectedState,
}: InformationControlProps) => {
  return (
    <Box
      w="100%"
      bg="white"
      p={3}
      borderRadius="xl"
      boxShadow="md"
      overflow="hidden"
    >
      <Tabs
        variant="soft-rounded"
        colorScheme="blue"
        index={tabIndex}
        onChange={handleTabChange}
        mb={2}
        size="sm"
      >
        <TabList
          overflowX="auto"
          pb={2}
          sx={{
            scrollbarWidth: "thin",
            "&::-webkit-scrollbar": {
              height: "6px",
            },
            "&::-webkit-scrollbar-thumb": {
              backgroundColor: "rgba(0, 0, 0, 0.1)",
              borderRadius: "3px",
            },
          }}
        >
          <Tab>Summary</Tab>
          <Tab>Districts Detail</Tab>
          <Tab>Gingles</Tab>
          <Tab>Box & Whisker</Tab>
          <Tab>Hierarchical</Tab>
        </TabList>
      </Tabs>

      {/* {selectedVisualization === "overview" && (
        <Box overflow="auto">
          <CongressionalTable
            data={mockData}
            onSelectDistrict={handleSelectDistrict}
          />
        </Box>
      )} */}

      <Box overflow="hidden">
        <BaseChart
          selectedState={selectedState}
          selectedVisualization={selectedVisualization}
          onSelectDistrict={handleSelectDistrict}
        />
      </Box>
    </Box>
  );
};

export default InformationControl;

================
File: dataVisuals/BoxplotComponent/AxisBottomCategoric.tsx
================
import { useMemo } from "react";
import { ScaleBand } from "d3";

type AxisBottomProps = {
  xScale: ScaleBand<string>;
};

// tick length
const TICK_LENGTH = 6;

export const AxisBottom = ({ xScale }: AxisBottomProps) => {
  const [min, max] = xScale.range();

  const ticks = useMemo(() => {
    return xScale.domain().map((value) => ({
      value,
      xOffset: xScale(value)! + xScale.bandwidth() / 2,
    }));
  }, [xScale]);

  return (
    <>
      {/* Main horizontal line */}
      <path
        d={["M", min + 20, 0, "L", max - 20, 0].join(" ")}
        fill="none"
        stroke="currentColor"
      />

      {/* Ticks and labels */}
      {ticks.map(({ value, xOffset }) => (
        <g key={value} transform={`translate(${xOffset}, 0)`}>
          <line y2={TICK_LENGTH} stroke="currentColor" />
          <text
            key={value}
            style={{
              fontSize: "10px",
              textAnchor: "middle",
              transform: "translateY(20px)",
            }}
          >
            {value}
          </text>
        </g>
      ))}
    </>
  );
};

================
File: dataVisuals/BoxplotComponent/AxisLeft.tsx
================
import { useMemo } from "react";
import { ScaleLinear } from "d3";

type AxisLeftProps = {
  yScale: ScaleLinear<number, number>;
  pixelsPerTick: number;
};

// tick length
const TICK_LENGTH = 6;

export const AxisLeft = ({ yScale, pixelsPerTick }: AxisLeftProps) => {
  const range = yScale.range();

  const ticks = useMemo(() => {
    const height = range[0] - range[1];
    const numberOfTicksTarget = Math.floor(height / pixelsPerTick);

    return yScale.ticks(numberOfTicksTarget).map((value) => ({
      value,
      yOffset: yScale(value),
    }));
  }, [yScale]);

  return (
    <>
      {/* Main vertical line */}
      <path
        d={["M", 0, range[0], "L", 0, range[1]].join(" ")}
        fill="none"
        stroke="currentColor"
      />

      {/* Ticks and labels */}
      {ticks.map(({ value, yOffset }) => (
        <g key={value} transform={`translate(0, ${yOffset})`}>
          <line x2={-TICK_LENGTH} stroke="currentColor" />
          <text
            key={value}
            style={{
              fontSize: "10px",
              textAnchor: "middle",
              transform: "translateX(-20px)",
            }}
          >
            {value}
          </text>
        </g>
      ))}
    </>
  );
};

================
File: dataVisuals/BoxplotComponent/BoxplotWrapper.tsx
================
import { useMemo } from "react";
import * as d3 from "d3";
import { AxisLeft } from "./AxisLeft";
import { AxisBottom } from "./AxisBottomCategoric";
import { VerticalBox } from "./VerticalBox";
import { useToast } from "@chakra-ui/react";

const MARGIN = { top: 30, right: 30, bottom: 100, left: 100 }; // Increased bottom and left margins for labels
const JITTER_WIDTH = 40;

type BoxplotWrapperProps = {
  width: number;
  height: number;
  data: { geoId: string; boxPlot: { min: number; q1: number; median: number; q3: number; max: number } }[];
  yAxis: string;
};

export const BoxplotWrapper = ({ width, height, data, yAxis }: BoxplotWrapperProps) => {
  const boundsWidth = width - MARGIN.right - MARGIN.left;
  const boundsHeight = height - MARGIN.top - MARGIN.bottom;
  const toast = useToast();

  // Compute derived data
  const { chartMax, groups } = useMemo(() => {
    const chartMax = d3.max(data.map((d) => d.boxPlot.max))!;
    const groups = data.map((d) => d.geoId);
    return { chartMax, groups };
  }, [data]);

  // Y Scale: Start from 0 and go to the maximum value
  const yScale = d3.scaleLinear().domain([0, chartMax]).range([boundsHeight, 0]);

  // X Scale
  const xScale = d3.scaleBand().range([0, boundsWidth]).domain(groups).padding(0.25);

  // Color Scale
  const colorScale = d3
    .scaleOrdinal<string>()
    .domain(groups)
    .range(["#e0ac2b", "#e85252", "#6689c6", "#9a6fb0", "#a53253"]);

  // Render the shapes for each group
  const allShapes = groups.map((geoId, i) => {
    const boxData = data.find((d) => d.geoId === geoId)?.boxPlot;
    if (!boxData) return null;

    const { min, q1, median, q3, max } = boxData;

    return (
      <g key={i} transform={`translate(${xScale(geoId)},0)`}>
        <VerticalBox
          width={xScale.bandwidth()}
          q1={yScale(q1)}
          median={yScale(median)}
          q3={yScale(q3)}
          min={yScale(min)}
          max={yScale(max)}
          stroke="black"
          fill={colorScale(geoId)}
        />
      </g>
    );
  });
  
  return (
    <svg width={width} height={height}>
      <g
        width={boundsWidth}
        height={boundsHeight}
        transform={`translate(${MARGIN.left},${MARGIN.top})`}
      >
        {allShapes}
        <AxisLeft yScale={yScale} pixelsPerTick={30} />
        <g transform={`translate(0, ${boundsHeight})`}>
          <AxisBottom xScale={xScale} />
        </g>
      </g>
      {/* Y-axis Label */}
      <text
        transform={`translate(${MARGIN.left / 2}, ${height / 2}) rotate(-90)`}
        textAnchor="middle"
        fontSize="12"
        fill="black"
      >
        {yAxis}
      </text>
      {/* X-axis Label */}
      <text
        transform={`translate(${width / 2}, ${height - MARGIN.bottom / 2})`}
        textAnchor="middle"
        fontSize="12"
        fill="black"
      >
        District
      </text>
    </svg>
  );
};

================
File: dataVisuals/BoxplotComponent/VerticalBox.tsx
================
const STROKE_WIDTH = 40;

// A reusable component that builds a vertical box shape using svg
// Note: numbers here are px, not the real values in the dataset.

type VerticalBoxProps = {
  min: number;
  q1: number;
  median: number;
  q3: number;
  max: number;
  width: number;
  stroke: string;
  fill: string;
};

export const VerticalBox = ({
  min,
  q1,
  median,
  q3,
  max,
  width,
  stroke,
  fill,
}: VerticalBoxProps) => {
  return (
    <>
      <line
        x1={width / 2}
        x2={width / 2}
        y1={min}
        y2={max}
        stroke={stroke}
        width={STROKE_WIDTH}
      />
      <rect
        x={0}
        y={q3}
        width={width}
        height={q1 - q3}
        stroke={stroke}
        fill={fill}
      />
      <line
        x1={0}
        x2={width}
        y1={median}
        y2={median}
        stroke={stroke}
        width={STROKE_WIDTH}
      />
    </>
  );
};

================
File: dataVisuals/gingles/Gingles.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { Box, VStack, HStack, Text, Select, ButtonGroup, Button } from '@chakra-ui/react';
import {
  ComposedChart,
  Scatter,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Label,
  Legend,
  Line,
  ResponsiveContainer
} from 'recharts';
import { stateConversion } from '../../../utils/util';

// Define available demographic categories
type DemographicKey = 'hispanic' | 'white' | 'black' | 'asian' | 'other';
type UrbanityFilter = 'all' | 'urban' | 'rural' | 'suburban';

// Define the structure of precinct data
type PrecinctData = {
  geoId: string;
  demographicGroupPercentage: number;
  totalPopulation: number;
  averageHouseholdIncome: number;
  normalizedValue: number;
  urbanicity: string;
  electionData: {
    biden_votes: number;
    trump_votes: number;
    other_votes: number;
    total_votes: number;
    biden_ratio: number;
    trump_ratio: number;
    party: string;
  };
};

interface GinglesProps {
  selectedState: string;
}

const Gingles: React.FC<GinglesProps> = ({ selectedState }) => {
  const [selectedDemographic, setSelectedDemographic] = useState<DemographicKey>('white');
  const [urbanityFilter, setUrbanityFilter] = useState<UrbanityFilter>('all');
  const [rawData, setRawData] = useState<PrecinctData[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [includeIncome, setIncludeIncome] = useState<boolean>(false);

  const demographicOptions: Record<DemographicKey, { name: string; description: string }> = {
    hispanic: { 
      name: 'Hispanic or Latino',
      description: 'Persons of Hispanic or Latino origin (of any race)'
    },
    white: { 
      name: 'White',
      description: 'Persons identifying as White alone'
    },
    black: { 
      name: 'Black',
      description: 'Persons identifying as Black or African American alone'
    },
    asian: { 
      name: 'Asian',
      description: 'Persons identifying as Asian alone'
    },
    other: {
      name: 'Other',
      description: 'Any other race'
    }
  };

  useEffect(() => {
    const fetchPrecinctData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const url = new URL('http://localhost:8080/api/graph/gingles');
        url.searchParams.append('state', stateConversion(selectedState));
        url.searchParams.append('demographicGroup', selectedDemographic);
        url.searchParams.append('includeIncome', 'false');

        const response = await fetch(url.toString());
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log('Received data:', data[0]); // Debug log
        setRawData(data);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
        setError(`Failed to load precinct data: ${errorMessage}`);
        console.error('Error fetching data:', err);
      } finally {
        setIsLoading(false);
      }
    };

    if (selectedState !== 'State') {
      fetchPrecinctData();
    }
  }, [selectedState, selectedDemographic]);


  const processedData = useMemo(() => {
    if (!Array.isArray(rawData) || rawData.length === 0) return null;

    // Filter by urbanicity first
    const filteredData = urbanityFilter === 'all' 
      ? rawData 
      : rawData.filter(precinct => 
          precinct.urbanicity?.toLowerCase() === urbanityFilter.toLowerCase()
        );

    // Transform data for Democratic vote share
    const democraticPoints = filteredData
      .filter(precinct => 
        typeof precinct.demographicGroupPercentage === 'number' && 
        precinct.electionData?.biden_ratio != null &&
        precinct.electionData.total_votes > 0
      )
      .map(precinct => ({
        x: precinct.demographicGroupPercentage * 100,
        y: precinct.electionData.biden_ratio * 100,
        party: 'Democratic',
        geoId: precinct.geoId,
        population: precinct.totalPopulation,
        votes: precinct.electionData.biden_votes,
        totalVotes: precinct.electionData.total_votes,
        urbanicity: precinct.urbanicity
      }));

    const republicanPoints = filteredData
      .filter(precinct => 
        typeof precinct.demographicGroupPercentage === 'number' && 
        precinct.electionData?.trump_ratio != null &&
        precinct.electionData.total_votes > 0
      )
      .map(precinct => ({
        x: precinct.demographicGroupPercentage * 100,
        y: precinct.electionData.trump_ratio * 100,
        party: 'Republican',
        geoId: precinct.geoId,
        population: precinct.totalPopulation,
        votes: precinct.electionData.trump_votes,
        totalVotes: precinct.electionData.total_votes,
        urbanicity: precinct.urbanicity
      }));

    // Calculate trend lines using  regression
    const calculateTrendLine = (points: any[]) => {
      if (points.length < 4) return []; // Need at least 4 points for  regression
      
      const coefficients = regression(points, 3);
      if (!coefficients) return [];

      // Generate points for the trend line
      const xValues = points.map(p => p.x);
      const minX = Math.min(...xValues);
      const maxX = Math.max(...xValues);
      const numPoints = 100;
      const step = (maxX - minX) / (numPoints - 1);
      
      return Array.from({ length: numPoints }, (_, i) => {
        const x = minX + i * step;
        // Calculate y using polynomial equation
        const y = coefficients.reduce((sum, coeff, power) => 
          sum + coeff * Math.pow(x, power), 0);
        // Clamp y values to valid percentage range [0, 100]
        const trendValue = Math.min(Math.max(y, 0), 100);
        return { x, trendValue };
      });
    };

    return {
      democratic: democraticPoints,
      republican: republicanPoints,
      demTrend: calculateTrendLine(democraticPoints),
      repTrend: calculateTrendLine(republicanPoints)
    };
  }, [rawData, urbanityFilter]);

  // Custom tooltip component
  const CustomTooltip: React.FC<{ active?: boolean; payload?: any[] }> = ({ active, payload }) => {
    if (!active || !payload || !payload[0]) return null;

    const data = payload[0].payload;
    return (
      <Box bg="white" p={3} border="1px solid" borderColor="gray.200" borderRadius="md" boxShadow="md">
        <Text fontWeight="bold">{`Precinct: ${data.geoId}`}</Text>
        <Text>{`${demographicOptions[selectedDemographic].name} Population: ${data.x.toFixed(1)}%`}</Text>
        <Text>{`Vote Share: ${(data.y ?? data.trendValue ?? 0).toFixed(1)}%`}</Text>
        {data.party && (
          <Text color={data.party === 'Democratic' ? '#2E5EAA' : '#AA2E2E'}>
            {`${data.party} Party`}
          </Text>
        )}
        <Text>{`Area Type: ${data.urbanicity || 'Unknown'}`}</Text>
        <Text>{`Total Population: ${data.population?.toLocaleString() ?? 'N/A'}`}</Text>
        {data.votes && (
          <Text>{`Votes: ${data.votes.toLocaleString()} / ${data.totalVotes.toLocaleString()}`}</Text>
        )}
      </Box>
    );
  };

  return (
    <VStack spacing={4} w="100%" p={4} bg="white" borderRadius="lg" boxShadow="sm">
      <HStack justify="space-between" w="100%" align="center">
      <Text fontSize="xl" fontWeight="bold">
        {selectedState} Precinct Analysis: {demographicOptions[selectedDemographic].name}
      </Text>
        <Select 
          value={selectedDemographic} 
          onChange={(e) => setSelectedDemographic(e.target.value as DemographicKey)}
          bg="blue.50"
          w="250px"
          isDisabled={isLoading}
        >
          {Object.entries(demographicOptions).map(([key, value]) => (
            <option key={key} value={key} title={value.description}>
              {value.name}
            </option>
          ))}
        </Select>
      </HStack>

      <Box w="100%" h="500px" position="relative">
        {isLoading ? (
          <Box position="absolute" top="50%" left="50%" transform="translate(-50%, -50%)">
            <Text fontSize="lg">Loading precinct data...</Text>
          </Box>
        ) : processedData ? (
          <ResponsiveContainer>
            <ComposedChart margin={{ top: 20, right: 30, bottom: 60, left: 40 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#E2E8F0" />
              <XAxis 
                type="number" 
                dataKey="x" 
                domain={[0, 100]}
                tickFormatter={(value) => `${value}%`}
              >
                <Label 
                  value={`${demographicOptions[selectedDemographic].name} Population Percentage`} 
                  position="bottom" 
                  offset={20} 
                />
              </XAxis>
              <YAxis 
                type="number" 
                dataKey="y" 
                domain={[0, 100]}
                tickFormatter={(value) => `${value}%`}
              >
                <Label 
                  value="Vote Share (%)" 
                  angle={-90} 
                  position="left" 
                  offset={30} 
                />
              </YAxis>
              <Tooltip content={CustomTooltip} />
              <Legend verticalAlign="bottom" height={36} />

              <Scatter 
                name="Democratic Vote Share"
                data={processedData.democratic} 
                fill="#2E5EAA"
                fillOpacity={0.6}
              />
              <Line
                name="Democratic Trend"
                data={processedData.demTrend}
                type="monotone"
                dataKey="trendValue"
                stroke="#2E5EAA"
                strokeWidth={2}
                dot={false}
                connectNulls
              />

              <Scatter 
                name="Republican Vote Share"
                data={processedData.republican} 
                fill="#AA2E2E"
                fillOpacity={0.6}
              />
              <Line
                name="Republican Trend"
                data={processedData.repTrend}
                type="monotone"
                dataKey="trendValue"
                stroke="#AA2E2E"
                strokeWidth={2}
                dot={false}
                connectNulls
              />
            </ComposedChart>
          </ResponsiveContainer>
        ) : null}
      </Box>

      <ButtonGroup variant="outline" spacing={4}>
        <Button
          onClick={() => setUrbanityFilter('all')}
          colorScheme={urbanityFilter === 'all' ? 'blue' : 'gray'}
        >
          All Areas
        </Button>
        <Button
          onClick={() => setUrbanityFilter('urban')}
          colorScheme={urbanityFilter === 'urban' ? 'blue' : 'gray'}
        >
          Urban
        </Button>
        <Button
          onClick={() => setUrbanityFilter('suburban')}
          colorScheme={urbanityFilter === 'suburban' ? 'blue' : 'gray'}
        >
          Suburban
        </Button>
        <Button
          onClick={() => setUrbanityFilter('rural')}
          colorScheme={urbanityFilter === 'rural' ? 'blue' : 'gray'}
        >
          Rural
        </Button>
      </ButtonGroup>
    </VStack>
  );
};

export default Gingles;

const regression = (points: Array<{x: number; y: number}>, degree: number = 3) => {
  // Skip if not enough points
  if (points.length < degree + 1) return null;

  // Create matrices for the linear system
  const matrix: number[][] = [];
  const vector: number[] = [];
  
  // Fill the matrices based on the polynomial degree
  for (let i = 0; i <= degree; i++) {
    matrix[i] = [];
    for (let j = 0; j <= degree; j++) {
      let sum = 0;
      for (const point of points) {
        sum += Math.pow(point.x, i + j);
      }
      matrix[i][j] = sum;
    }
    
    let sum = 0;
    for (const point of points) {
      sum += point.y * Math.pow(point.x, i);
    }
    vector[i] = sum;
  }

  // Solve using Gaussian elimination
  for (let i = 0; i < degree + 1; i++) {
    // Find pivot
    let maxRow = i;
    for (let j = i + 1; j < degree + 1; j++) {
      if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxRow][i])) {
        maxRow = j;
      }
    }

    // Swap rows if needed
    [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];
    [vector[i], vector[maxRow]] = [vector[maxRow], vector[i]];

    // Eliminate column
    for (let j = i + 1; j < degree + 1; j++) {
      const factor = matrix[j][i] / matrix[i][i];
      for (let k = i; k < degree + 1; k++) {
        matrix[j][k] -= factor * matrix[i][k];
      }
      vector[j] -= factor * vector[i];
    }
  }

  // Back substitution
  const coefficients = new Array(degree + 1).fill(0);
  for (let i = degree; i >= 0; i--) {
    let sum = vector[i];
    for (let j = i + 1; j < degree + 1; j++) {
      sum -= matrix[i][j] * coefficients[j];
    }
    coefficients[i] = sum / matrix[i][i];
  }

  return coefficients;
};

================
File: dataVisuals/gingles/IncomeGingles.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { Box, VStack, HStack, Text, ButtonGroup, Button, useToast } from '@chakra-ui/react';
import {
  ComposedChart,
  Scatter,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Label,
  Legend,
  Line,
  ResponsiveContainer
} from 'recharts';

type PrecinctData = {
  geoId: string;
  demographicGroupPercentage: number;
  totalPopulation: number;
  averageHouseholdIncome: number;
  normalizedValue: number;
  urbanicity: string;
  electionData: {
    biden_votes: number;
    trump_votes: number;
    other_votes: number;
    total_votes: number;
    biden_ratio: number;
    trump_ratio: number;
  };
};

type UrbanityFilter = 'all' | 'urban' | 'rural' | 'suburban';

interface IncomeGinglesProps {
  selectedState: string;
}
const polynomialRegression = (points: Array<{x: number; y: number}>, degree: number = 3) => {
    // Matrix operations for polynomial regression
    const generateMatrix = (points: Array<{x: number; y: number}>, degree: number) => {
      const matrix = Array(degree + 1).fill(0).map(() => Array(degree + 1).fill(0));
      const vector = Array(degree + 1).fill(0);
  
      points.forEach(point => {
        for (let i = 0; i <= degree; i++) {
          for (let j = 0; j <= degree; j++) {
            matrix[i][j] += Math.pow(point.x, i + j);
          }
          vector[i] += point.y * Math.pow(point.x, i);
        }
      });
  
      return { matrix, vector };
    };
  
    // Gaussian elimination
    const solve = (matrix: number[][], vector: number[]) => {
      const n = vector.length;
      const coefficients = Array(n).fill(0);
      
      for (let i = 0; i < n; i++) {
        // Find pivot
        let maxRow = i;
        for (let j = i + 1; j < n; j++) {
          if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxRow][i])) {
            maxRow = j;
          }
        }
  
        // Swap maximum row with current row
        [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];
        [vector[i], vector[maxRow]] = [vector[maxRow], vector[i]];
  
        // Eliminate column
        for (let j = i + 1; j < n; j++) {
          const factor = matrix[j][i] / matrix[i][i];
          vector[j] -= factor * vector[i];
          for (let k = i; k < n; k++) {
            matrix[j][k] -= factor * matrix[i][k];
          }
        }
      }
  
      // Back substitution
      for (let i = n - 1; i >= 0; i--) {
        let sum = 0;
        for (let j = i + 1; j < n; j++) {
          sum += matrix[i][j] * coefficients[j];
        }
        coefficients[i] = (vector[i] - sum) / matrix[i][i];
      }
  
      return coefficients;
    };
  
    const { matrix, vector } = generateMatrix(points, degree);
    const coefficients = solve(matrix, vector);
  
    return (x: number) => {
      return coefficients.reduce((sum, coeff, power) => 
        sum + coeff * Math.pow(x, power), 0);
    };
  };


const IncomeGingles: React.FC<IncomeGinglesProps> = ({ selectedState }) => {
  const [rawData, setRawData] = useState<PrecinctData[]>([]);
  const [urbanityFilter, setUrbanityFilter] = useState<UrbanityFilter>('all');
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const toast = useToast();

  useEffect(() => {
    const fetchPrecinctData = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const url = new URL('http://localhost:8080/api/graph/gingles');
        url.searchParams.append('state', selectedState.toLowerCase().replace(" ", ""));
        url.searchParams.append('includeIncome', 'true');

        const response = await fetch(url.toString());
        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        setRawData(data);
      } catch (err) {
        const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
        setError(`Failed to load precinct data: ${errorMessage}`);
        console.error('Error fetching data:', err);
        
        toast({
          title: 'Error fetching data',
          description: errorMessage,
          status: 'error',
          duration: 5000,
          isClosable: true,
        });
      } finally {
        setIsLoading(false);
      }
    };

    fetchPrecinctData();
  }, [selectedState, toast]);

    const processedData = useMemo(() => {
    if (!Array.isArray(rawData) || rawData.length === 0) return null;

    // Filter data based on urbanicity selection
    const filteredData = urbanityFilter === 'all' 
      ? rawData 
      : rawData.filter(precinct => 
          precinct.urbanicity?.toLowerCase() === urbanityFilter
        );

    // Transform data for Democratic vote share
    const democraticPoints = filteredData
      .filter(precinct => 
        precinct?.averageHouseholdIncome != null && 
        precinct?.electionData?.biden_votes != null &&
        precinct.electionData.total_votes > 0
      )
      .map(precinct => ({
        x: precinct.averageHouseholdIncome,
        y: precinct.electionData.biden_ratio * 100,
        party: 'Democratic',
        geoId: precinct.geoId,
        population: precinct.totalPopulation,
        votes: precinct.electionData.biden_votes,
        totalVotes: precinct.electionData.total_votes,
        urbanicity: precinct.urbanicity
      }));

    const republicanPoints = filteredData
      .filter(precinct => 
        precinct?.averageHouseholdIncome != null && 
        precinct?.electionData?.trump_votes != null &&
        precinct.electionData.total_votes > 0
      )
      .map(precinct => ({
        x: precinct.averageHouseholdIncome,
        y: precinct.electionData.trump_ratio * 100,
        party: 'Republican',
        geoId: precinct.geoId,
        population: precinct.totalPopulation,
        votes: precinct.electionData.trump_votes,
        totalVotes: precinct.electionData.total_votes,
        urbanicity: precinct.urbanicity
      }));

    // Calculate trend lines using polynomial regression
    const calculateTrendLine = (points: any[]) => {
      if (points.length === 0) return [];
      
      const xValues = points.map(p => p.x);
      const minX = Math.min(...xValues);
      const maxX = Math.max(...xValues);
      
      // Get regression function
      const regression = polynomialRegression(
        points.map(p => ({ x: p.x, y: p.y })),
        3  // cubic polynomial
      );
      
      // Generate smooth curve points
      const numPoints = 100;
      const step = (maxX - minX) / (numPoints - 1);
      
      return Array.from({ length: numPoints }, (_, i) => {
        const x = minX + i * step;
        const trendValue = regression(x);
        // Clamp values to valid percentage range
        return {
          x,
          trendValue: Math.min(Math.max(trendValue, 0), 100)
        };
      });
    };

    return {
      democratic: democraticPoints,
      republican: republicanPoints,
      demTrend: calculateTrendLine(democraticPoints),
      repTrend: calculateTrendLine(republicanPoints)
    };
  }, [rawData, urbanityFilter]);


  // Custom tooltip component
  const CustomTooltip: React.FC<{ active?: boolean; payload?: any[] }> = ({ active, payload }) => {
    if (!active || !payload || !payload[0]) return null;

    const data = payload[0].payload;
    return (
      <Box bg="white" p={3} border="1px solid" borderColor="gray.200" borderRadius="md" boxShadow="md">
        <Text fontWeight="bold">{`Precinct: ${data.geoId}`}</Text>
        <Text>{`Income: $${data.x.toLocaleString()}`}</Text>
        <Text>{`Vote Share: ${(data.y ?? data.trendValue ?? 0).toFixed(1)}%`}</Text>
        {data.party && (
          <Text color={data.party === 'Democratic' ? '#2E5EAA' : '#AA2E2E'}>
            {`${data.party} Party`}
          </Text>
        )}
        <Text>{`Area Type: ${data.urbanicity || 'Unknown'}`}</Text>
        {data.votes && (
          <Text>{`Votes: ${data.votes.toLocaleString()} / ${data.totalVotes.toLocaleString()}`}</Text>
        )}
      </Box>
    );
  };

  return (
    <VStack spacing={4} w="100%" p={4} bg="white" borderRadius="lg" boxShadow="sm">
      {/* ... (previous JSX remains the same) */}
      <Box w="100%" h="500px" position="relative">
        {isLoading ? (
          <Box position="absolute" top="50%" left="50%" transform="translate(-50%, -50%)">
            <Text fontSize="lg">Loading precinct data...</Text>
          </Box>
        ) : processedData ? (
          <ResponsiveContainer>
            <ComposedChart margin={{ top: 20, right: 30, bottom: 60, left: 40 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#E2E8F0" />
              <XAxis 
                type="number" 
                dataKey="x" 
                domain={['auto', 'auto']}
                tickFormatter={(value) => `$${(value/1000).toFixed(0)}k`}
              >
                <Label 
                  value="Average Household Income" 
                  position="bottom" 
                  offset={20} 
                />
              </XAxis>
              <YAxis 
                type="number" 
                dataKey="y" 
                domain={[0, 100]}
                tickFormatter={(value) => `${value}%`}
              >
                <Label 
                  value="Vote Share (%)" 
                  angle={-90} 
                  position="left" 
                  offset={30} 
                />
              </YAxis>
              <Tooltip content={CustomTooltip} />
              <Legend verticalAlign="bottom" height={36} />

              <Scatter 
                name="Democratic Vote Share"
                data={processedData.democratic} 
                fill="#2E5EAA"
                fillOpacity={0.6}
              />
              <Line
                name="Democratic Trend"
                data={processedData.demTrend}
                type="monotone"
                dataKey="trendValue"
                stroke="#2E5EAA"
                strokeWidth={2}
                dot={false}
                connectNulls
              />

              <Scatter 
                name="Republican Vote Share"
                data={processedData.republican} 
                fill="#AA2E2E"
                fillOpacity={0.6}
              />
              <Line
                name="Republican Trend"
                data={processedData.repTrend}
                type="monotone"
                dataKey="trendValue"
                stroke="#AA2E2E"
                strokeWidth={2}
                dot={false}
                connectNulls
              />
            </ComposedChart>
          </ResponsiveContainer>
        ) : null}
      </Box>

      <ButtonGroup variant="outline" spacing={4}>
        <Button
          onClick={() => setUrbanityFilter('all')}
          colorScheme={urbanityFilter === 'all' ? 'blue' : 'gray'}
        >
          All Areas
        </Button>
        <Button
          onClick={() => setUrbanityFilter('urban')}
          colorScheme={urbanityFilter === 'urban' ? 'blue' : 'gray'}
        >
          Urban
        </Button>
        <Button
          onClick={() => setUrbanityFilter('suburban')}
          colorScheme={urbanityFilter === 'suburban' ? 'blue' : 'gray'}
        >
          Suburban
        </Button>
        <Button
          onClick={() => setUrbanityFilter('rural')}
          colorScheme={urbanityFilter === 'rural' ? 'blue' : 'gray'}
        >
          Rural
        </Button>
      </ButtonGroup>
    </VStack>
  );
};

export default IncomeGingles;

================
File: dataVisuals/gingles/NormalizedGingles.tsx
================
import React, { useState, useEffect, useMemo } from 'react';
import { Box, VStack, HStack, Text, Select, ButtonGroup, Button } from '@chakra-ui/react';
import {
  ComposedChart,
  Scatter,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Label,
  Legend,
  Line,
  ResponsiveContainer
} from 'recharts';

type UrbanityFilter = 'all' | 'urban' | 'rural' | 'suburban';
type DemographicKey = 'hispanic' | 'white' | 'black' | 'asian';

type PrecinctData = {
  geoId: string;
  normalizedValue: number;
  totalPopulation: number;
  urbanicity: string;
  electionData: {
    biden_votes: number;
    trump_votes: number;
    other_votes: number;
    total_votes: number;
    biden_ratio: number;
    trump_ratio: number;
    party: string;
  };
};

interface GinglesIncomeProps {
  selectedState: string;
}

const NormalizedGingles: React.FC<GinglesIncomeProps> = ({ selectedState }) => {
    const [urbanityFilter, setUrbanityFilter] = useState<UrbanityFilter>('all');
    const [selectedDemographic, setSelectedDemographic] = useState<DemographicKey>('white');
    const [rawData, setRawData] = useState<PrecinctData[]>([]);
    const [isLoading, setIsLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
  
    // Define demographic options
    const demographicOptions: Record<DemographicKey, { name: string; description: string }> = {
      hispanic: { 
        name: 'Hispanic or Latino',
        description: 'Persons of Hispanic or Latino origin (of any race)'
      },
      white: { 
        name: 'White',
        description: 'Persons identifying as White alone'
      },
      black: { 
        name: 'Black',
        description: 'Persons identifying as Black or African American alone'
      },
      asian: { 
        name: 'Asian',
        description: 'Persons identifying as Asian alone'
      }
    };

    
    useEffect(() => {
        const fetchPrecinctData = async () => {
          setIsLoading(true);
          setError(null);
          try {
            const url = new URL('http://localhost:8080/api/graph/gingles');
            url.searchParams.append('state', selectedState.toLowerCase().replace(" ", ""));
            url.searchParams.append('demographicGroup', selectedDemographic);
            url.searchParams.append('includeIncome', 'true');
    
            console.log('Fetching from URL:', url.toString());
    
            const response = await fetch(url.toString());
            
            if (!response.ok) {
              throw new Error(`HTTP error! status: ${response.status}`);
            }
    
            const data = await response.json();
            setRawData(data);
          } catch (err) {
            const errorMessage = err instanceof Error ? err.message : 'Unknown error occurred';
            setError(`Failed to load precinct data: ${errorMessage}`);
            console.error('Error fetching data:', err);
          } finally {
            setIsLoading(false);
          }
        };
    
        if (selectedState !== 'State') {
          fetchPrecinctData();
        }
      }, [selectedState, selectedDemographic]);

  // Helper function for polynomial regression
  const polynomialRegression = (points: Array<{x: number; y: number}>, degree: number = 3) => {
    if (points.length < degree + 1) return null;

    const matrix: number[][] = [];
    const vector: number[] = [];
    
    for (let i = 0; i <= degree; i++) {
      matrix[i] = [];
      for (let j = 0; j <= degree; j++) {
        let sum = 0;
        for (const point of points) {
          sum += Math.pow(point.x, i + j);
        }
        matrix[i][j] = sum;
      }
      
      let sum = 0;
      for (const point of points) {
        sum += point.y * Math.pow(point.x, i);
      }
      vector[i] = sum;
    }

    // Gaussian elimination
    for (let i = 0; i < degree + 1; i++) {
      let maxRow = i;
      for (let j = i + 1; j < degree + 1; j++) {
        if (Math.abs(matrix[j][i]) > Math.abs(matrix[maxRow][i])) {
          maxRow = j;
        }
      }

      [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];
      [vector[i], vector[maxRow]] = [vector[maxRow], vector[i]];

      for (let j = i + 1; j < degree + 1; j++) {
        const factor = matrix[j][i] / matrix[i][i];
        for (let k = i; k < degree + 1; k++) {
          matrix[j][k] -= factor * matrix[i][k];
        }
        vector[j] -= factor * vector[i];
      }
    }

    const coefficients = new Array(degree + 1).fill(0);
    for (let i = degree; i >= 0; i--) {
      let sum = vector[i];
      for (let j = i + 1; j < degree + 1; j++) {
        sum -= matrix[i][j] * coefficients[j];
      }
      coefficients[i] = sum / matrix[i][i];
    }

    return coefficients;
  };

  const processedData = useMemo(() => {
    if (!Array.isArray(rawData) || rawData.length === 0) return null;

    const filteredData = urbanityFilter === 'all' 
      ? rawData 
      : rawData.filter(precinct => 
          precinct.urbanicity?.toLowerCase() === urbanityFilter.toLowerCase()
        );

    const democraticPoints = filteredData
      .filter(precinct => 
        typeof precinct.normalizedValue === 'number' && 
        precinct.electionData?.biden_ratio != null &&
        precinct.electionData.total_votes > 0
      )
      .map(precinct => ({
        x: precinct.normalizedValue,
        y: precinct.electionData.biden_ratio * 100,
        party: 'Democratic',
        geoId: precinct.geoId,
        population: precinct.totalPopulation,
        votes: precinct.electionData.biden_votes,
        totalVotes: precinct.electionData.total_votes,
        urbanicity: precinct.urbanicity
      }));

    const republicanPoints = filteredData
      .filter(precinct => 
        typeof precinct.normalizedValue === 'number' && 
        precinct.electionData?.trump_ratio != null &&
        precinct.electionData.total_votes > 0
      )
      .map(precinct => ({
        x: precinct.normalizedValue,
        y: precinct.electionData.trump_ratio * 100,
        party: 'Republican',
        geoId: precinct.geoId,
        population: precinct.totalPopulation,
        votes: precinct.electionData.trump_votes,
        totalVotes: precinct.electionData.total_votes,
        urbanicity: precinct.urbanicity
      }));

          // Calculate trend lines using polynomial regression
    const calculateTrendLine = (points: any[]) => {
        if (points.length < 4) return [];
        
        const coefficients = polynomialRegression(points, 3);
        if (!coefficients) return [];
  
        const xValues = points.map(p => p.x);
        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);
        const numPoints = 100;
        const step = (maxX - minX) / (numPoints - 1);
        
        return Array.from({ length: numPoints }, (_, i) => {
          const x = minX + i * step;
          const y = coefficients.reduce((sum, coeff, power) => 
            sum + coeff * Math.pow(x, power), 0);
          const trendValue = Math.min(Math.max(y, 0), 100);
          return { x, trendValue };
        });
      };

      
    return {
      democratic: democraticPoints,
      republican: republicanPoints,
      demTrend: calculateTrendLine(democraticPoints),
      repTrend: calculateTrendLine(republicanPoints)
    };
  }, [rawData, urbanityFilter]);

  // Custom tooltip component
  const CustomTooltip: React.FC<{ active?: boolean; payload?: any[] }> = ({ active, payload }) => {
    if (!active || !payload || !payload[0]) return null;

    const data = payload[0].payload;
    return (
      <Box bg="white" p={3} border="1px solid" borderColor="gray.200" borderRadius="md" boxShadow="md">
        <Text fontWeight="bold">{`Precinct: ${data.geoId}`}</Text>
        <Text>{`Normalized Income: ${data.x.toFixed(2)}`}</Text>
        <Text>{`Vote Share: ${(data.y ?? data.trendValue ?? 0).toFixed(1)}%`}</Text>
        {data.party && (
          <Text color={data.party === 'Democratic' ? '#2E5EAA' : '#AA2E2E'}>
            {`${data.party} Party`}
          </Text>
        )}
        <Text>{`Area Type: ${data.urbanicity || 'Unknown'}`}</Text>
        <Text>{`Total Population: ${data.population?.toLocaleString() ?? 'N/A'}`}</Text>
        {data.votes && (
          <Text>{`Votes: ${data.votes.toLocaleString()} / ${data.totalVotes.toLocaleString()}`}</Text>
        )}
      </Box>
    );
  };

  return (
    <VStack spacing={4} w="100%" p={4} bg="white" borderRadius="lg" boxShadow="sm">
      <Text fontSize="xl" fontWeight="bold">
        {selectedState.toUpperCase()} Income vs. Voting Patterns
      </Text>

      <Box w="100%" h="500px" position="relative">
        {isLoading ? (
          <Box position="absolute" top="50%" left="50%" transform="translate(-50%, -50%)">
            <Text fontSize="lg">Loading precinct data...</Text>
          </Box>
        ) : processedData ? (
          <ResponsiveContainer>
            <ComposedChart margin={{ top: 20, right: 30, bottom: 60, left: 40 }}>
              <CartesianGrid strokeDasharray="3 3" stroke="#E2E8F0" />
              <XAxis 
                type="number" 
                dataKey="x" 
                domain={['auto', 'auto']}
              >
                <Label 
                  value="Normalized Income" 
                  position="bottom" 
                  offset={20} 
                />
              </XAxis>
              <YAxis 
                type="number" 
                dataKey="y" 
                domain={[0, 100]}
                tickFormatter={(value) => `${value}%`}
              >
                <Label 
                  value="Vote Share (%)" 
                  angle={-90} 
                  position="left" 
                  offset={30} 
                />
              </YAxis>
              <Tooltip content={CustomTooltip} />
              <Legend verticalAlign="bottom" height={36} />

              <Scatter 
                name="Democratic Vote Share"
                data={processedData.democratic} 
                fill="#2E5EAA"
                fillOpacity={0.6}
              />
              <Line
                name="Democratic Trend"
                data={processedData.demTrend}
                type="monotone"
                dataKey="trendValue"
                stroke="#2E5EAA"
                strokeWidth={2}
                dot={false}
                connectNulls
              />

              <Scatter 
                name="Republican Vote Share"
                data={processedData.republican} 
                fill="#AA2E2E"
                fillOpacity={0.6}
              />
              <Line
                name="Republican Trend"
                data={processedData.repTrend}
                type="monotone"
                dataKey="trendValue"
                stroke="#AA2E2E"
                strokeWidth={2}
                dot={false}
                connectNulls
              />
            </ComposedChart>
          </ResponsiveContainer>
        ) : null}
      </Box>

      <ButtonGroup variant="outline" spacing={4}>
        <Button
          onClick={() => setUrbanityFilter('all')}
          colorScheme={urbanityFilter === 'all' ? 'blue' : 'gray'}
        >
          All Areas
        </Button>
        <Button
          onClick={() => setUrbanityFilter('urban')}
          colorScheme={urbanityFilter === 'urban' ? 'blue' : 'gray'}
        >
          Urban
        </Button>
        <Button
          onClick={() => setUrbanityFilter('suburban')}
          colorScheme={urbanityFilter === 'suburban' ? 'blue' : 'gray'}
        >
          Suburban
        </Button>
        <Button
          onClick={() => setUrbanityFilter('rural')}
          colorScheme={urbanityFilter === 'rural' ? 'blue' : 'gray'}
        >
          Rural
        </Button>
      </ButtonGroup>
    </VStack>
  );
};

export default NormalizedGingles;

================
File: dataVisuals/BaseChart.tsx
================
import React from "react";
import { Box, Spinner, Center } from "@chakra-ui/react";
import Gingles from "./gingles/Gingles";
import { VisualizationType } from "../../types/ChartDataItemInterface";
import StateSummary from "./StateSummary";
import DistrictDetail from "./DistrictDetail";
import GinglesControl from "../controls/GinglesControl";
import BoxPlot from "./Boxplot";
import { stateConversion } from "../../utils/util";

interface ChartDataItem {
  name: string;
  value: number;
}

interface SummaryData {
  "racial population": Record<string, number>;
  "population by income": Record<string, number>;
  "vote distribution": Record<string, number>;
  "population percentage by region": {
    Rural: string;
    Urban: string;
    Suburban: string;
  };
  "congressional representatives": Array<Record<string, string>>;
  population: number;
}

interface BaseChartProps {
  selectedState: string;
  selectedVisualization?: VisualizationType;
  onSelectDistrict: (district: number | null) => void;
}

const BaseChart: React.FC<BaseChartProps> = ({
  selectedState,
  selectedVisualization = "summary",
  onSelectDistrict
}) => {
  const [stateSummaryData, setStateSummaryData] = React.useState<SummaryData | null>(null);
  const [isLoading, setIsLoading] = React.useState(false);
  const [error, setError] = React.useState<string | null>(null);

  React.useEffect(() => {
    const fetchStateSummary = async () => {
      setIsLoading(true);
      setError(null);
      try {
        const response = await fetch(
          `http://localhost:8080/api/summary?state=${stateConversion(selectedState)}`
        );
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        console.log("Fetched data:", data); // Debug log
        setStateSummaryData(data);
      } catch (error) {
        console.error("Error fetching state summary:", error);
        setError(error instanceof Error ? error.message : "Failed to fetch data");
        setStateSummaryData(null);
      } finally {
        setIsLoading(false);
      }
    };

    if (selectedState && selectedVisualization === "summary") {
      fetchStateSummary();
    }
  }, [selectedState, selectedVisualization]);

  const transformDataToArray = (data: Record<string, number>): ChartDataItem[] => {
    if (!data) return [];
    return Object.entries(data).map(([name, value]) => ({
      name,
      value: typeof value === 'string' ? parseFloat(value) : value
    }));
  };

  const transformRegionData = (data: Record<string, string>): ChartDataItem[] => {
    if (!data) return [];
    return Object.entries(data).map(([name, value]) => ({
      name: name.toLowerCase(),
      value: parseFloat(value)
    }));
  };

  const renderVisualization = () => {
    if (isLoading) {
      return (
        <Center h="400px">
          <Spinner size="xl" color="blue.500" />
        </Center>
      );
    }

    if (error) {
      return (
        <Center h="400px">
          <Box color="red.500">Error loading data: {error}</Box>
        </Center>
      );
    }

    switch (selectedVisualization) {
      case "summary":
        if (!stateSummaryData) return null;
        
        return (
          <StateSummary
            racialData={transformDataToArray(stateSummaryData["racial population"])}
            incomeData={transformDataToArray(stateSummaryData["population by income"])}
            voteData={transformDataToArray(stateSummaryData["vote distribution"])}
            regionData={transformRegionData(stateSummaryData["population percentage by region"])}
            totalPopulation={stateSummaryData.population}
          />
        );
      case "districtDetail":
        return (
          <DistrictDetail
            onSelectDistrict={onSelectDistrict}
            selectedState={selectedState}
          />
        );
      case "gingles":
        return <GinglesControl selectedState={selectedState} />;
      case "boxplot":
        return <BoxPlot selectedState={selectedState} />;
      case "ecologicalInference":
        return null;
      default:
        return null;
    }
  };

  return <Box>{renderVisualization()}</Box>;
};

export default BaseChart;

================
File: dataVisuals/Boxplot.tsx
================
import React, { useEffect, useState, useRef } from "react";
import * as d3 from "d3";
import { DataItem } from "../../types/BoxPlot";
import { Box, HStack, Select, useToast, VStack } from "@chakra-ui/react";
import { stateConversion } from "../../utils/util";
import { BoxplotWrapper } from "./BoxplotComponent/BoxplotWrapper";

const BoxPlot = ({ selectedState }: { selectedState: string }) => {
  const [boxPlotData, setBoxPlotData] = useState<DataItem[]>([]);
  const [category, setCategory] = useState("demographic");
  const [range, setRange] = useState("white");
  const [regionType, setRegionTye] = useState("all");
  const toast = useToast();

  const race = ["white", "black", "asian", "hispanic", "other"];
  const incomeRanges = [
    "0-9999",
    "10k-15k",
    "15k-25k",
    "25k-35k",
    "35k-50k",
    "50k-75k",
    "75k-100k",
    "100k+",
  ];
  const incomeMap: Record<string, string> = {
    "0-9999": "from_0_to_9999",
    "10k-15k": "from_10000_to_14999",
    "15k-25k": "from_15000_to_24999",
    "25k-35k": "from_25000_to_34999",
    "35k-50k": "from_35000_to_49999",
    "50k-75k": "from_50000_to_74999",
    "75k-100k": "from_75000_to_99999",
    "100k+": "from_100000_and_more",
  };

  useEffect(() => {
    const fetchStateSummary = async (
      selectedState: string,
      category: string,
      regionType: string,
      range: string
    ) => {
      const query = new URLSearchParams({
        state: stateConversion(selectedState),
        category: category,
        regionType: regionType,
      });
      if (category === "economic") {
        range = incomeMap[range];
      }
      if (range) {
        query.set("range", range);
      }
      const response = await fetch(
        "http://localhost:8080/api/graph/boxplot?" + query
      );
      const json = await response.json();
      return json;
    };

    const loadBoxPlot = async () => {
      const result = await fetchStateSummary(
        selectedState,
        category,
        category !== "urbanicity" ? regionType : "all",
        range
      );
      setBoxPlotData(result);
      if (result.length == 0) {
        toast({
          title: `Error fetching data`,
          description: `No data for ${regionType + " " + category + " data"}`,
          status: "error",
          duration: 5000,
          isClosable: true,
        });
      }
    };

    loadBoxPlot();
  }, [category, range, regionType, selectedState]);

  return (
    <VStack>
      <Box>
        <HStack>
          <Select
            onChange={(e) => {
              setCategory(e.target.value);
              switch (e.target.value) {
                case "demographic":
                  setRange("white");
                  break;
                case "economic":
                  setRange("0-9999");
                  break;
                case "urbanicity":
                  setRange("rural");
                  break;
              }
            }}
          >
            <option>demographic</option>
            <option>economic</option>
            <option>urbanicity</option>
          </Select>
          {category === "demographic" && (
            <Select onChange={(e) => setRange(e.target.value)}>
              {race.map((r) => (
                <option key={r}>{r}</option>
              ))}
            </Select>
          )}

          {category === "urbanicity" && (
            <Select onChange={(e) => setRange(e.target.value)}>
              <option>rural</option>
              <option>suburban</option>
              <option>urban</option>
            </Select>
          )}

          {category === "economic" && (
            <Select onChange={(e) => setRange(e.target.value)}>
              {incomeRanges.map((i) => (
                <option key={i}>{i}</option>
              ))}
            </Select>
          )}

          {category !== "urbanicity" && (
            <Select onChange={(e) => setRegionTye(e.target.value)}>
              <option>all</option>
              <option>rural</option>
              <option>suburban</option>
              <option>urban</option>
            </Select>
          )}
        </HStack>
      </Box>
      <Box>
        <div>
          <h2>Boxplot Visualization</h2>
          <BoxplotWrapper
            yAxis={category + " percentage"}
            width={750}
            height={400}
            data={boxPlotData.map((item) => ({
              geoId: item.geoId,
              boxPlot: item.boxPlot,
            }))}
          />
        </div>
      </Box>
    </VStack>
  );
};

export default BoxPlot;

================
File: dataVisuals/ComparisonOverlay.tsx
================
import React, { useEffect, useRef, useState } from "react";
import { Box, Flex, IconButton, Text } from "@chakra-ui/react";
import { CloseIcon } from "@chakra-ui/icons";
import L from "leaflet";
import axios from "axios";
import { GeoJsonObject } from "geojson";
import { stateConversion } from "../../utils/util";

interface ComparisonOverlayProps {
  isOpen: boolean;
  onClose: () => void;
  currentState: string;
  currentGeoJson: any;
  districtPlanNumber: string;
}

const ComparisonOverlay: React.FC<ComparisonOverlayProps> = ({
  isOpen,
  onClose,
  currentState,
  currentGeoJson,
  districtPlanNumber,
}) => {
  const originalMapRef = useRef<HTMLDivElement>(null);
  const planMapRef = useRef<HTMLDivElement>(null);
  const [originalMap, setOriginalMap] = useState<L.Map | null>(null);
  const [planMap, setPlanMap] = useState<L.Map | null>(null);
  const [districtPlanData, setDistrictPlanData] = useState<any>(null);

  // Refs to track GeoJSON layers
  const originalLayerRef = useRef<L.GeoJSON | null>(null);
  const planLayerRef = useRef<L.GeoJSON | null>(null);

  // Cleanup function for when component unmounts or overlay closes
  const cleanup = () => {
    if (originalLayerRef.current && originalMap) {
      originalMap.removeLayer(originalLayerRef.current);
      originalLayerRef.current = null;
    }
    if (planLayerRef.current && planMap) {
      planMap.removeLayer(planLayerRef.current);
      planLayerRef.current = null;
    }
    if (originalMap) {
      originalMap.remove();
      setOriginalMap(null);
    }
    if (planMap) {
      planMap.remove();
      setPlanMap(null);
    }
  };

  useEffect(() => {
    const fetchDistrictPlan = async () => {
      try {
        const response = await axios.get(
          `http://localhost:8080/api/map/districtplan?state=${(stateConversion(currentState)).toLowerCase()}&districtPlan=${districtPlanNumber}`
        );

        setDistrictPlanData(response.data);
      } catch (error) {
        console.error("Error fetching district plan:", error);
      }
    };

    if (isOpen && districtPlanNumber) {
      fetchDistrictPlan();
    }

    // Cleanup when component unmounts or overlay closes
    return () => {
      if (!isOpen) {
        cleanup();
      }
    };
  }, [isOpen, currentState, districtPlanNumber]);

  useEffect(() => {
    if (!isOpen || !originalMapRef.current || !planMapRef.current) return;

    // Initialize maps
    const initMap = (element: HTMLElement) => {
      const map = L.map(element, {
        zoomControl: true,
        dragging: true,
        scrollWheelZoom: true,
      });

      L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        minZoom: 3,
        maxZoom: 24,
        attribution:
          '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
      }).addTo(map);

      return map;
    };

    const map1 = initMap(originalMapRef.current);
    const map2 = initMap(planMapRef.current);

    setOriginalMap(map1);
    setPlanMap(map2);

    // Return cleanup function
    return () => cleanup();
  }, [isOpen]);

  useEffect(() => {
    if (!originalMap || !planMap) return;

    // Clear existing layers before adding new ones
    if (originalLayerRef.current) {
      originalMap.removeLayer(originalLayerRef.current);
    }
    if (planLayerRef.current) {
      planMap.removeLayer(planLayerRef.current);
    }

    // Add current districts to original map
    const addGeoJsonToMap = (map: L.Map, data: any, isOriginal: boolean) => {
      const layer = L.geoJSON(data as GeoJsonObject, {
        style: (feature) => {
          const defaultStyle: L.PathOptions = {
            fillColor: "#FFFFFF", // Default fill color if shading is not present
            color: "#000", // Border color
            weight: 0.5, // Border weight
            fillOpacity: 0.8, // Opacity of the fill
          };

          // Use the shading property to determine the fill color
          if (feature?.properties?.shading) {
            return {
              ...defaultStyle,
              fillColor: feature.properties.shading,
            };
          }

          return defaultStyle;
        },
      });

      // Store the layer reference
      if (isOriginal) {
        originalLayerRef.current = layer;
      } else {
        planLayerRef.current = layer;
      }

      // Add the layer to the map
      layer.addTo(map);

      // Adjust map bounds to fit the layer
      map.fitBounds(layer.getBounds());
    };

    // Add GeoJSON layers to both maps
    if (currentGeoJson) {
      addGeoJsonToMap(originalMap, currentGeoJson, true);
    }
    if (districtPlanData) {
      addGeoJsonToMap(planMap, districtPlanData, false);
    }
  }, [originalMap, planMap, currentGeoJson, districtPlanData]);

  const handleClose = () => {
    cleanup();
    onClose();
  };

  if (!isOpen) return null;

  return (
    <Box
      position="fixed"
      top="0"
      left="0"
      right="0"
      bottom="0"
      bg="rgba(0, 0, 0, 0.7)"
      zIndex={1000}
      display="flex"
      alignItems="center"
      justifyContent="center"
    >
      <Box
        bg="white"
        w="90%"
        h="80%"
        borderRadius="lg"
        overflow="hidden"
        position="relative"
        p={4}
      >
        <IconButton
          aria-label="Close comparison"
          icon={<CloseIcon />}
          position="absolute"
          right={2}
          top={2}
          zIndex={2}
          onClick={handleClose}
        />

        <Flex h="100%" gap={4}>
          <Box flex={1} position="relative">
            <Text fontSize="lg" fontWeight="bold" mb={2}>
              Current Districts
            </Text>
            <Box
              ref={originalMapRef}
              h="calc(100% - 40px)"
              borderRadius="md"
              overflow="hidden"
              border="1px solid"
              borderColor="gray.200"
            />
          </Box>

          <Box flex={1} position="relative">
            <Text fontSize="lg" fontWeight="bold" mb={2}>
              Proposed District Plan {districtPlanNumber}
            </Text>
            <Box
              ref={planMapRef}
              h="calc(100% - 40px)"
              borderRadius="md"
              overflow="hidden"
              border="1px solid"
              borderColor="gray.200"
            />
          </Box>
        </Flex>
      </Box>
    </Box>
  );
};

export default ComparisonOverlay;

================
File: dataVisuals/DistrictDetail.tsx
================
import { Box, Table, Thead, Tr, Th, Tbody, Td, Text } from "@chakra-ui/react";
import { useEffect, useState } from "react";
import CongressionalDistrictData, {
  CongressionalDistrictDataJson,
} from "../../types/CongressionalDistrictData";
import { stateConversion } from "../../utils/util";

interface DistrictDetailProps {
  onSelectDistrict: (district: number | null) => void;
  selectedState: string;
}

const DistrictDetail = ({
  onSelectDistrict,
  selectedState,
}: DistrictDetailProps) => {
  const [selectedDistrict, setSelectedDistrict] = useState<number | null>(null);
  const [districtTable, setDistrictTable] = useState<
    CongressionalDistrictData[]
  >([]);

  const handleRowClick = (district: number) => {
    if (selectedDistrict == district) {
      // if the same selected district is clicked again we will undo
      setSelectedDistrict(null);
      onSelectDistrict(null);
    } else {
      // district has not been selected we will select
      setSelectedDistrict(district);
      onSelectDistrict(district);
    }
  };

  useEffect(() => {
    const fetchDistribtTable = async (selectedState: string) => {
      const query = new URLSearchParams({
        state: selectedState,
      }).toString();
      const response = await fetch("http://localhost:8080/api/table?" + query);
      const json = await response.json();
      return json;
    };

    const loadDistrictTable = async () => {
      try {
        const rawDistrictTable = await fetchDistribtTable(
          stateConversion(selectedState)
        );

        // Transform congressional representatives into an array of objects with name and party
        setDistrictTable(
          rawDistrictTable
            .map((rawDistrictDetail: CongressionalDistrictDataJson) => {
              const districtDetail: CongressionalDistrictData = {
                district: Number(rawDistrictDetail.geoId),
                representative: rawDistrictDetail.data.rep,
                party: rawDistrictDetail.data.party,
                averageHouseholdIncome: rawDistrictDetail.data.averageIncome,
                povertyPercentage: rawDistrictDetail.data.povertyPercentage,
                regionType: {
                  rural: parseInt(rawDistrictDetail.data.ruralPercentage),
                  suburban: parseInt(rawDistrictDetail.data.subUrbanPercentage),
                  urban: parseInt(rawDistrictDetail.data.urbanPercentage),
                },
                voteMargin: Math.abs(
                  rawDistrictDetail.data.trumpVotes -
                    rawDistrictDetail.data.bidenVotes
                ),
              };
              return districtDetail;
            })
            .sort(
              (a: CongressionalDistrictData, b: CongressionalDistrictData) =>
                a.district - b.district
            )
        );
      } catch (error) {
        console.error("Error fetching state summary:", error);
      }
    };

    loadDistrictTable();
  }, [selectedState]);

  return (
    <Box
      overflowX="scroll"
      overflowY="scroll" // Enables vertical scrolling
      maxH="50vh" // Sets maximum height for the box
      p={1}
      borderWidth="1px"
      borderRadius="md"
      bg="white"
      boxShadow="sm"
    >
      <Text fontSize="sm" fontWeight="bold" mb={1} ml={2}>
        District Details
      </Text>
      <Table variant="simple" size="sm">
        <Thead>
          <Tr>
            <Th
              py={1}
              fontSize="xs"
              position="sticky" // Makes the header sticky
              top="-1" // Sticks the header to the top of the scrolling container
              bg="white" // Background color to avoid transparency issues
              zIndex="1" // Ensures the header appears above table content
            >
              District
            </Th>
            <Th
              py={1}
              fontSize="xs"
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Rep.
            </Th>
            <Th
              py={1}
              fontSize="xs"
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Party
            </Th>
            <Th
              py={1}
              fontSize="xs"
              isNumeric
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Average Household Income
            </Th>
            <Th
              py={1}
              fontSize="xs"
              isNumeric
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Poverty%
            </Th>
            <Th
              py={1}
              fontSize="xs"
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Rural Region%
            </Th>
            <Th
              py={1}
              fontSize="xs"
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Suburban Region%
            </Th>
            <Th
              py={1}
              fontSize="xs"
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Urban Region%
            </Th>
            <Th
              py={1}
              fontSize="xs"
              isNumeric
              position="sticky"
              top="-1"
              bg="white"
              zIndex="1"
            >
              Margin
            </Th>
          </Tr>
        </Thead>
        <Tbody>
          {districtTable.map((item) => (
            <Tr
              key={item.district}
              onClick={() => handleRowClick(item.district)}
              bg={selectedDistrict === item.district ? "blue.50" : "white"}
              _hover={{ cursor: "pointer", bg: "blue.100" }}
            >
              <Td py={0.5} fontSize="xs">
                {item.district}
              </Td>
              <Td py={0.5} fontSize="xs">
                {item.representative}
              </Td>
              <Td py={0.5} fontSize="xs">
                {item.party}
              </Td>
              <Td py={0.5} fontSize="xs" isNumeric>
                ${item.averageHouseholdIncome.toLocaleString()}
              </Td>
              <Td py={0.5} fontSize="xs" isNumeric>
                {item.povertyPercentage.toFixed(1)}%
              </Td>
              <Td py={0.5} fontSize="xs">
                {`${item.regionType.rural}%`}
              </Td>
              <Td py={0.5} fontSize="xs">
                {`${item.regionType.suburban}%`}
              </Td>
              <Td py={0.5} fontSize="xs">
                {`${item.regionType.urban}%`}
              </Td>
              <Td py={0.5} fontSize="xs" isNumeric>
                {item.voteMargin.toFixed(1)}
              </Td>
            </Tr>
          ))}
        </Tbody>
      </Table>
    </Box>
  );
};

export default DistrictDetail;

================
File: dataVisuals/Pie.tsx
================
import React from 'react';
import { Box, Text, useColorModeValue } from '@chakra-ui/react';
import {
  PieChart,
  Pie,
  Cell,
  Tooltip,
  ResponsiveContainer,
  Legend
} from 'recharts';

const COLORS = [
  '#2E5EAA', // Primary blue
  '#FF6B6B', // Coral
  '#4CAF50', // Green
  '#FFA726', // Orange
  '#9575CD', // Purple
  '#4DB6AC', // Teal
  '#FFD54F', // Amber
  '#7986CB'  // Indigo
];

interface ChartDataItem {
  name: string;
  value: number;
}

const PieChartComponent = ({ data, title }: { data: ChartDataItem[], title: string }) => {
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.100', 'gray.700');
  
  const total = data.reduce((sum, item) => sum + item.value, 0);
  const processedData = data.map(item => ({
    ...item,
    percent: total > 0 ? item.value / total : 0
  }));

  const formatLabel = (name: string) => {
    return name.split(' ').map(word => {
      if (word.toLowerCase() === 'suburban' || word.toLowerCase() === 'urban' || word.toLowerCase() === 'rural') {
        return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
      }
      return word;
    }).join(' ');
  };

  const CustomLabel = ({ cx, cy, midAngle, innerRadius, outerRadius, percent, name }: any) => {
    if (!percent || percent < 0.02) return null;
    
    const RADIAN = Math.PI / 180;
    const radius = innerRadius + (outerRadius - innerRadius) * 1.1;
    const x = cx + radius * Math.cos(-midAngle * RADIAN);
    const y = cy + radius * Math.sin(-midAngle * RADIAN);
    
    const formattedName = formatLabel(name);
    const formattedPercent = (percent * 100).toFixed(1);
    const textAnchor = x > cx ? 'start' : 'end';
    
    return (
      <text
        x={x}
        y={y}
        fill="#4A5568"
        textAnchor={textAnchor}
        fontSize="11px"
        dominantBaseline="central"
      >
        {`${formattedName}: ${formattedPercent}%`}
      </text>
    );
  };

  const CustomTooltip = ({ active, payload }: any) => {
    if (!active || !payload?.length) return null;
    
    const formattedName = formatLabel(payload[0].name);
    return (
      <Box
        bg={bgColor}
        p={2}
        borderRadius="md"
        boxShadow="lg"
        border="1px"
        borderColor={borderColor}
      >
        <Text fontWeight="semibold">{formattedName}</Text>
        <Text fontSize="sm">
          Count: {payload[0].value.toLocaleString()}
        </Text>
        <Text fontSize="sm" color="gray.600">
          Percentage: {(payload[0].payload.percent * 100).toFixed(1)}%
        </Text>
      </Box>
    );
  };

  if (!data.length) {
    return (
      <Box
        bg={bgColor}
        p={4}
        borderRadius="xl"
        boxShadow="sm"
        border="1px"
        borderColor={borderColor}
        height="300px"
        display="flex"
        alignItems="center"
        justifyContent="center"
      >
        <Text color="gray.500">No data available</Text>
      </Box>
    );
  }

  return (
    <Box height="100%" width="100%">
      <Text
        fontSize="sm"
        fontWeight="semibold"
        textAlign="center"
        color="gray.700"
        mb={2}
      >
        {title}
      </Text>
      <Box height="calc(100% - 30px)"> {/* Adjust for title height */}
        <ResponsiveContainer width="100%" height="100%">
          <PieChart>
            <Pie
              data={data}
              cx="50%"
              cy="50%"
              labelLine={false}
              label={CustomLabel}
              outerRadius="85%"
              fill="#8884d8"
              dataKey="value"
            >
              {data.map((_, index) => (
                <Cell
                  key={`cell-${index}`}
                  fill={COLORS[index % COLORS.length]}
                  stroke={bgColor}
                  strokeWidth={2}
                />
              ))}
            </Pie>
            <Tooltip content={CustomTooltip} />
            <Legend 
              verticalAlign="bottom" 
              align="center"
              layout="horizontal"
              height={36}
            />
          </PieChart>
        </ResponsiveContainer>
      </Box>
    </Box>
  );
};

export default PieChartComponent;

================
File: dataVisuals/StateOverviewChart.tsx
================
// StateOverviewChart.tsx
import React from 'react';
import { Box, Text, useColorModeValue } from '@chakra-ui/react';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Label,
  ResponsiveContainer,
  Cell
} from 'recharts';

const COLORS = [
  '#2E5EAA', '#FF6B6B', '#4CAF50', '#FFA726',
  '#9575CD', '#4DB6AC', '#FFD54F', '#7986CB'
];

interface ChartDataItem {
  name: string;
  value: number;
}

const StateOverviewChart = ({
  data,
  title,
  xAxisLabel,
  height
}: {
  data: ChartDataItem[];
  title: string;
  xAxisLabel: string;
  height: string;
}) => {
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.100', 'gray.700');

  const CustomTooltip = ({ active, payload, label }: any) => {
    if (!active || !payload?.length) return null;

    return (
      <Box
        bg={bgColor}
        p={3}
        borderRadius="md"
        boxShadow="lg"
        border="1px"
        borderColor={borderColor}
      >
        <Text fontWeight="semibold">{label}</Text>
        <Text fontSize="sm">
          Population: {payload[0].value.toLocaleString()}
        </Text>
      </Box>
    );
  };

  return (
    <Box
      bg={bgColor}
      p={4}
      borderRadius="xl"
      boxShadow="sm"
      border="1px"
      borderColor={borderColor}
      height="350px "  // Fixed height that works well with the layout
      transition="transform 0.2s"
      _hover={{ transform: 'translateY(-2px)', boxShadow: 'md' }}
    >
      <Text
        fontSize="lg"
        fontWeight="semibold"
        mb={3}
        textAlign="center"
        color="gray.700"
      >
        {title}
      </Text>
      <Box height="calc(100% - 35px)">
        <ResponsiveContainer width="100%" height="100%">
          <BarChart
            data={data}
            margin={{ top: 20, right: 45, bottom: 45, left: 45 }}  // Adjusted margins
          >
            <CartesianGrid strokeDasharray="3 3" stroke="#E2E8F0" opacity={0.5} />
            <XAxis
              dataKey="name"
              tick={{ fontSize: 12, fill: '#4A5568' }}
              tickLine={{ stroke: '#4A5568' }}
              height={60}  // Increased height for better label visibility
            >
              <Label
                value={xAxisLabel}
                position="bottom"
                offset={-10}
                style={{ fontSize: '13px', fill: '#4A5568' }}
              />
            </XAxis>
            <YAxis
              tick={{ fontSize: 12, fill: '#4A5568' }}
              tickLine={{ stroke: '#4A5568' }}
              width={70}  // Increased width for better number visibility
              tickFormatter={(value) => value.toLocaleString()}  // Format large numbers
            >
              <Label
                value="Population"
                angle={-90}
                position="insideLeft"
                offset={-15}
                style={{ fontSize: '13px', fill: '#4A5568' }}
              />
            </YAxis>
            <Tooltip content={CustomTooltip} />
            <Bar
              dataKey="value"
              fill={COLORS[0]}
              radius={[4, 4, 0, 0]}
              maxBarSize={65}  // Slightly wider bars
            >
              {data.map((_, index) => (
                <Cell
                  key={`cell-${index}`}
                  fill={COLORS[index % COLORS.length]}
                />
              ))}
            </Bar>
          </BarChart>
        </ResponsiveContainer>
      </Box>
    </Box>
  );
};

export default StateOverviewChart;

================
File: dataVisuals/StateSummary.tsx
================
// StateSummary.tsx
import React from 'react';
import { Box, Grid, Text, VStack } from '@chakra-ui/react';
import PieChartComponent from './Pie';
import StateOverviewChart from './StateOverviewChart';

interface ChartDataItem {
  name: string;
  value: number;
}

interface StateSummaryProps {
  racialData: ChartDataItem[];
  incomeData: ChartDataItem[];
  voteData: ChartDataItem[];
  regionData: ChartDataItem[];
  totalPopulation: number;
}

const StateSummary = ({
  racialData,
  incomeData,
  voteData,
  regionData,
  totalPopulation
}: StateSummaryProps) => {
  const chartHeight = "190px  "; // Reduced height for the right-side charts
  const bottomHeight = "200px"; // Height for the bottom chart

  return (
    <Box p={4}>
      <Text fontSize="lg" fontWeight="semibold" mb={4}>
        Total Population: {totalPopulation.toLocaleString()}
      </Text>
      
      {/* Grid for charts */}
      <Grid
        templateColumns={{ base: "1fr", lg: "repeat(2, 1fr)" }}
        gap={6}
        mb={6}
      >
        <Box
          bg="white"
          p={4}
          borderRadius="xl"
          boxShadow="sm"
          height={chartHeight}
        >
          <PieChartComponent
            data={voteData}
            title="Voter Distribution"
          />
        </Box>
        <Box
          bg="white"
          p={4}
          borderRadius="xl"
          boxShadow="sm"
          height={chartHeight}
        >
          <PieChartComponent
            data={incomeData}
            title="Income Distribution"
          />
        </Box>
      </Grid>
      
      <Box mt={6}>
        <StateOverviewChart
          data={racialData} 
          title="Population Distribution by Race"
          xAxisLabel="Race"
          height={bottomHeight}
        />
      </Box>
    </Box>
  );
};

export default StateSummary;

================
File: Main.tsx
================
import { useEffect, useState } from "react";
import {
  Box,
  Flex,
  useBreakpointValue,
  ResponsiveValue,
  VStack,
  SlideFade,
  ScaleFade,
  Container,
} from "@chakra-ui/react";
import USMap from "./USMap";
import Navbar from "./Navbar";
import Frame from "./ui";
import { HeatmapType } from "./controls/HeatMapControls";
import InformationControl from "./controls/InformationControl";
import { VisualizationType } from "../types/ChartDataItemInterface";
import PieChartComponent from "./dataVisuals/Pie";
import { stateConversion } from "../utils/util";

const MainLayout = () => {
  const [selectedState, setSelectedState] = useState<string>("State");
  const [select, onSelectChange] = useState<string>("Default");
  const [districtData, setDistrictData] = useState("");
  const [isDataVisible, setIsDataVisible] = useState(false);
  const [shouldFadeOut, setShouldFadeOut] = useState(false);
  const [selectedVisualization, setSelectedVisualization] = useState<VisualizationType>("summary");
  const [geoLevel, setGeoLevel] = useState<"district" | "precinct">("district");
  const [heatmapType, setHeatmapType] = useState<HeatmapType>("none");
  const [selectedDistrict, setSelectedDistrict] = useState<number | null>(null);
  const [tabIndex, setTabIndex] = useState(0);
  const [selectedDemographic, setSelectedDemographic] = useState<string>("white");
  const [stateSummaryData, setStateSummaryData] = useState<any>(null);

  const direction = useBreakpointValue({
    base: "column",
    md: "row",
  }) as ResponsiveValue<"column" | "row">;

  useEffect(() => {
    const fetchSummaryData = async () => {
      if (selectedState === "State") return;
      try {
        const response = await fetch(
          `http://localhost:8080/api/summary?state=${stateConversion(selectedState)}`
        );
        const data = await response.json();
        setStateSummaryData(data);
      } catch (error) {
        console.error("Error fetching summary data:", error);
      }
    };

    fetchSummaryData();
  }, [selectedState]);

  useEffect(() => {
    if (selectedState !== "State") {
      if (isDataVisible) {
        setShouldFadeOut(true);
        setTimeout(() => {
          setShouldFadeOut(false);
          setIsDataVisible(true);
        }, 300);
      } else {
        setShouldFadeOut(false);
        setTimeout(() => {
          setIsDataVisible(true);
        }, 300);
      }
    } else {
      setShouldFadeOut(true);
      setTimeout(() => {
        setIsDataVisible(false);
        setShouldFadeOut(false);
      }, 300);
    }
  }, [selectedState]);

  const handleTabChange = (index: number) => {
    setTabIndex(index);
    const visualizations: VisualizationType[] = [
      "summary",
      "districtDetail",
      "gingles",
      "boxplot",
      "ecologicalInference",
    ];
    setSelectedVisualization(visualizations[index]);
    if (index !== 1) {
      setSelectedDistrict(null);
    }
  };

  const transformRegionData = (data: any) => {
    if (!data) return [];
    const regionData = data["population percentage by region"];
    return Object.entries(regionData).map(([name, value]) => ({
      name: name.toLowerCase(),
      value: typeof value === 'string' ? parseFloat(value) : (value as number)
    }));
  };

  const showRegionPieChart = selectedState !== "State" && 
                            stateSummaryData && 
                            selectedVisualization === "summary";

  const mapHeight = showRegionPieChart 
    ? "calc(55vh - 20px)"
    : "calc(85vh - 20px)"; // Extended height when pie chart is hidden

    return (
      <Frame>
        <Container maxW="100%" px={4} minH="calc(100vh - 60px)"> {/* Increased minimum height */}
          <VStack spacing={4} align="stretch" w="100%" minH="calc(100vh - 80px)">
            <Box>
              <Navbar
                onSelectChange={onSelectChange}
                select={select}
                onStateChange={setSelectedState}
                state={selectedState}
                setSelectedVisualization={setSelectedVisualization}
                geoLevel={geoLevel}
                onGeoLevelChange={setGeoLevel}
                heatmapType={heatmapType}
                onHeatmapChange={setHeatmapType}
                onDemographicChange={setSelectedDemographic}
                setTabIndex={handleTabChange}
              />
            </Box>
  
            <Flex 
              direction={direction} 
              w="100%" 
              gap={6}  // Increased gap
              justify="space-between"
              flex={1}
              minH={0}
              pb={6}  // Added bottom padding
            >
              <Flex
                direction="column"
                width={selectedState !== "State" ? { base: "100%", lg: "40%" } : "100%"}
                gap={6}  // Increased gap
              >
                <Box flex={1} minH={0}>
                  <USMap
                    onStateSelect={setSelectedState}
                    selectedState={selectedState}
                    selectedData={select}
                    setDistrictData={setDistrictData}
                    geoLevel={geoLevel}
                    heatmapType={heatmapType}
                    selectedDistrict={selectedDistrict}
                    selectedDemographic={selectedDemographic}
                  />
                </Box>
  
                {showRegionPieChart && (
                  <SlideFade in={true} offsetY="20px">
                    <Box
                      bg="white"
                      p={4}
                      borderRadius="xl"
                      boxShadow="sm"
                      height="300px"
                      width="100%"
                    >
                      <PieChartComponent
                        data={transformRegionData(stateSummaryData)}
                        title="Population by Region Type"
                      />
                    </Box>
                  </SlideFade>
                )}
              </Flex>
  
              {selectedState !== "State" && (
                <Box flex={1} minH={0}>
                  <SlideFade
                    in={isDataVisible && !shouldFadeOut}
                    offsetX="20px"
                    transition={{
                      enter: { duration: 0.5 },
                      exit: { duration: 0.3 },
                    }}
                  >
                    <ScaleFade
                      initialScale={0.9}
                      in={isDataVisible && !shouldFadeOut}
                      transition={{
                        enter: { duration: 0.5 },
                        exit: { duration: 0.3 },
                      }}
                    >
                      <Box maxH="calc(100vh - 120px)" overflowY="auto">
                        <InformationControl
                          tabIndex={tabIndex}
                          handleSelectDistrict={setSelectedDistrict}
                          handleTabChange={handleTabChange}
                          selectedVisualization={selectedVisualization}
                          selectedState={selectedState}
                        />
                      </Box>
                    </ScaleFade>
                  </SlideFade>
                </Box>
              )}
            </Flex>
          </VStack>
        </Container>
      </Frame>
    );
  };
  
  export default MainLayout;

================
File: MapLegend.tsx
================
import React from 'react';
import { Box, VStack, HStack, Text, Square } from '@chakra-ui/react';
import { HeatmapType } from './controls/HeatMapControls';

interface MapLegendProps {
  heatmapType: HeatmapType;
  selectedDemographic?: string;
}

const MapLegend: React.FC<MapLegendProps> = ({ heatmapType, selectedDemographic }) => {
  const getLegendItems = () => {
    switch (heatmapType) {
      case 'demographic':
        return {
          title: `${selectedDemographic?.charAt(0).toUpperCase()}${selectedDemographic?.slice(1)} %`,
          items: [
            { color: '#FFE5E5', label: '0-20%' },
            { color: '#FF9999', label: '20-40%' },
            { color: '#FF4D4D', label: '40-60%' },
            { color: '#CC0000', label: '60-80%' },
            { color: '#660000', label: '80-100%' }
          ]
        };

      case 'poverty':
        return {
          title: 'Poverty Level',
          items: [
            { color: '#E5F2FF', label: 'Low' },
            { color: '#99CCF3', label: 'Medium-Low' },
            { color: '#4D9BE6', label: 'Medium' },
            { color: '#0066CC', label: 'Medium-High' },
            { color: '#003366', label: 'High' }
          ]
        };

      case 'economic':
        return {
          title: 'Income Level',
          items: [
            { color: '#E5FFE5', label: 'Low' },
            { color: '#99FF99', label: 'Medium-Low' },
            { color: '#4DFF4D', label: 'Medium' },
            { color: '#00CC00', label: 'Medium-High' },
            { color: '#006600', label: 'High' }
          ]
        };

      case 'politicalincome':
        return {
          title: 'Income by Party',
          items: [
            { color: '#FF9999', label: 'Low Rep.' },
            { color: '#FF0000', label: 'High Rep.' },
            { color: '#9999FF', label: 'Low Dem.' },
            { color: '#0000FF', label: 'High Dem.' }
          ]
        };

      case 'none':
      default:
        return {
          title: 'Political Leaning',
          items: [
            { color: '#0000FF', label: 'Democratic' },
            { color: '#FF5733', label: 'Republican' }
          ]
        };
    }
  };

  const legend = getLegendItems();

  return (
    <Box
      position="absolute"
      bottom="20px"
      right="10px"
      bg="rgba(255, 255, 255, 0.8)"
      borderRadius="sm"
      boxShadow="0 0 15px rgba(0,0,0,0.2)"
      p={2}
      zIndex={1000}
      maxW="150px"
      w="auto"
    >
      <VStack align="start" spacing={0.5}>
        <Text fontWeight="bold" fontSize="xs" w="100%" mb={1}>
          {legend.title}
        </Text>
        {legend.items.map((item, index) => (
          <HStack key={index} spacing={1} w="100%">
            <Square 
              size="12px" 
              bg={item.color} 
              border="1px solid" 
              borderColor="gray.300"
              opacity={0.7}
            />
            <Text fontSize="10px" flex="1">
              {item.label}
            </Text>
          </HStack>
        ))}
      </VStack>
    </Box>
  );
};

export default MapLegend;

================
File: Navbar.tsx
================
import React from "react";
import {
  Box,
  HStack,
  Heading,
  Select,
  Button,
  ButtonGroup,
} from "@chakra-ui/react";
import { RepeatIcon } from "@chakra-ui/icons";
import { VisualizationType } from "../types/ChartDataItemInterface";
import HeatmapControls, { HeatmapType } from "./controls/HeatMapControls";

interface NavbarProps {
  onSelectChange: (val: string) => void;
  select: string;
  onStateChange: (val: string) => void;
  state: string;
  setSelectedVisualization: (type: VisualizationType) => void;
  geoLevel: "district" | "precinct";
  onGeoLevelChange: (level: "district" | "precinct") => void;
  heatmapType: HeatmapType;
  onHeatmapChange: (type: HeatmapType) => void;
  onDemographicChange: (group: string) => void;
  setTabIndex: (tabIndex: number) => void;
}

const Navbar: React.FC<NavbarProps> = ({
  onSelectChange,
  select,
  onStateChange,
  state,
  setSelectedVisualization,
  geoLevel,
  onGeoLevelChange,
  heatmapType,
  onHeatmapChange,
  onDemographicChange,
  setTabIndex
}) => {
  const handleReset = () => {
    onStateChange("State");
    setSelectedVisualization("standard");
    onHeatmapChange("none");
    setTabIndex(0);
  };

  // New handler for geo level changes
  const handleGeoLevelChange = (level: "district" | "precinct") => {
    // If switching to district view, automatically disable heatmap
    if (level === "district") {
      onHeatmapChange("none");
    }
    onGeoLevelChange(level);
  };

  return (
    <HStack justify="space-between" width="100%" align="center">
      <Heading as="h1" size="l" textAlign="center">
        US Political Map
      </Heading>
      <HStack spacing={4}>
        <HStack spacing={2}>
          <Select
            onChange={(e: React.ChangeEvent<HTMLSelectElement>) => {
              onStateChange(e.target.value);
            }}
            value={state}
            bg="white"
            width="200px"
          >
            <option>State</option>
            <option>New York</option>
            <option>Arkansas</option>
          </Select>
          {state !== "State" && (
            <>
              <ButtonGroup isAttached variant="solid" size="md">
                <Button
                  onClick={() => handleGeoLevelChange("district")}
                  bg={geoLevel === "district" ? "#F7CFF2" : "white"}
                  _hover={{ bg: "#F7CFF2" }}
                  borderRadius="md"
                  borderRight="1px solid"
                  borderColor="gray.200"
                >
                  Districts
                </Button>
                <Button
                  onClick={() => handleGeoLevelChange("precinct")}
                  bg={geoLevel === "precinct" ? "#F7CFF2" : "white"}
                  _hover={{ bg: "#F7CFF2" }}
                  borderRadius="md"
                >
                  Precincts
                </Button>
              </ButtonGroup>
              {geoLevel === "precinct" && (
                <HeatmapControls
                  isEnabled={true}
                  onHeatmapChange={onHeatmapChange}
                  currentType={heatmapType}
                  onDemographicChange={onDemographicChange}
                />
              )}
            </>
          )}
          <Button
            onClick={handleReset}
            bg="white"
            _hover={{ bg: "#F7CFF2" }}
            aria-label="Reset selection"
            title="Reset selection"
          >
            <RepeatIcon />
          </Button>
        </HStack>
      </HStack>
    </HStack>
  );
};

export default Navbar;

================
File: ui.tsx
================
import React, { useEffect, useState } from 'react';
import { Box, Flex, VStack, Text, keyframes, SlideFade, ScaleFade } from '@chakra-ui/react';
import { ReactNode } from 'react';

const fadeInColor = keyframes`
  0% { opacity: 0; }
  100% { opacity: 1; }
`;

interface UIProps {
  children: ReactNode;
}

const UI: React.FC<UIProps> = ({ children }) => {
  const [showNav, setShowNav] = useState(false);
  const [showContent, setShowContent] = useState(false);

  useEffect(() => {
    const navTimer = setTimeout(() => setShowNav(true), 800);
    const contentTimer = setTimeout(() => setShowContent(true), 1600);

    return () => {
      clearTimeout(navTimer);
      clearTimeout(contentTimer);
    };
  }, []);

  const fadeAnimation = `${fadeInColor} 2s ease-in`;

  return (
    <Box 
      bg="#FFF0E6" 
      minHeight="100vh"
      maxWidth="1600px"
      margin="0 auto"
      animation={fadeAnimation}
      position="relative"
      overflow="hidden"
    >
      <Flex direction="column" width="100%" p={2} gap={2}>
        <SlideFade 
          in={showNav} 
          offsetY="-20px"
          transition={{ enter: { duration: 1.2 } }}
        >
          <Box 
            as="nav" 
            bg="rgba(255, 240, 229, 0)" 
            py={1}
            px={2}
            backdropFilter="blur(5px)" 
            position="sticky" 
            top={0} 
            zIndex={10}
            borderRadius="lg"
            boxShadow="sm"
            transition="background-color 2s ease-in-out, box-shadow 0.3s ease-in-out"
            _hover={{ bg: "rgba(255, 240, 229, 0.70)" }}
          >
            <Flex justify="center" align="center">
              <Text 
                fontSize="md"
                fontWeight="bold" 
                color="#494946"
                opacity={0}
                animation={`${fadeInColor} 2s ease-in forwards`}
                transition="all 0.3s ease-in-out"
                _hover={{ transform: 'scale(1.05)' }}
              >
                Team Hurricane
              </Text>
            </Flex>
          </Box>
        </SlideFade>

        <VStack spacing={4} align="stretch">
          <ScaleFade 
            in={showContent} 
            initialScale={0.95}
            transition={{ enter: { duration: 1.2 } }}
          >
            <Flex>
              <Box 
                flex={1} 
                bg="#E4EDC4" 
                borderRadius="xl" 
                p={4} 
                mr={4}
                boxShadow="md"
                opacity={0}
                animation={`${fadeInColor} 2s ease-in forwards`}
                transition="all 0.3s ease-in-out, background-color 2s ease-in-out"
                _hover={{ boxShadow: "lg" }}
              >
                {children}
              </Box>
            </Flex>
          </ScaleFade>
        </VStack>
      </Flex>
    </Box>
  );
};

export default UI;

================
File: USMap.tsx
================
import React, { useEffect, useRef, useCallback, useState } from "react";
import L from "leaflet";
import { GeoJsonObject, Feature, Geometry } from "geojson";
import axios from "axios";
import statesData from "../map/state";
import { Box, Flex, HStack, Text, VStack } from "@chakra-ui/react";
import "../style/legend.css";
import "leaflet/dist/leaflet.css";
import { HeatmapType } from "./controls/HeatMapControls";
import MapLegend from "./MapLegend";
// import DistrictPlanControls from "./controls/DistrictPlanControls";
// import { Layer, PathOptions } from "leaflet";
// import ComparisonOverlay from "./dataVisuals/ComparisonOverlay";

interface FeatureLayer extends L.Layer {
  feature?: any;
  setStyle(style: L.PathOptions): this;
}

interface MapData {
  type: string;
  geometry: {
    type: string;
    coordinates: number[][][];
  };
  properties?: any;
}

interface USMapProps {
  onStateSelect: (state: string) => void;
  selectedState: string | null;
  selectedData: string | null;
  setDistrictData: (state: string) => void;
  geoLevel: "district" | "precinct";
  heatmapType: HeatmapType;
  selectedDistrict: number | null;
  selectedDemographic: string;
  onDistrictSelect?: (district: string | null) => void;
}

const USMap: React.FC<USMapProps> = ({
  onStateSelect,
  selectedState,
  selectedData,
  setDistrictData,
  geoLevel,
  heatmapType,
  selectedDistrict,
  selectedDemographic,
  onDistrictSelect,
}) => {
  const [arkansasData, setArkansasData] = useState<{
    district?: MapData[];
    precinct?: MapData[];
  }>({});
  const [newYorkData, setNewYorkData] = useState<{
    district?: MapData[];
    precinct?: MapData[];
  }>({});
  const [map, setMap] = useState<L.Map | null>(null);
  const [heatmapData, setHeatmapData] = useState<any>(null);
  const [districtPlanData, setDistrictPlanData] = useState<any>(null);
  const mapRef = useRef<HTMLDivElement>(null);
  const geoLayerRef = useRef<L.GeoJSON | null>(null);
  const [isComparisonOpen, setIsComparisonOpen] = useState(false);
  const [selectedPlanNumber, setSelectedPlanNumber] = useState<string>("");

  const fetchDistrictPlan = async (state: string, planNumber: string) => {
    try {
      const response = await axios.get(
        `http://localhost:8080/api/map/districtplan?state=${state.toLowerCase()}&districtPlan=${planNumber}`
      );
      setDistrictPlanData(response.data);
    } catch (error) {
      console.error("Error fetching district plan:", error);
    }
  };

  const fetchHeatmapData = useCallback(
    async (state: string, type: HeatmapType, demographicGroup?: string) => {
      if (type === "none") return null;

      const stateCode = state.toLowerCase().replace(" ", "");
      const baseUrl = "http://localhost:8080/api/heatmap";

      let url = "";
      switch (type) {
        case "demographic":
          url = `${baseUrl}/demographic?state=${stateCode}&demographicGroup=${
            demographicGroup || "white"
          }`;
          break;
        case "poverty":
          url = `${baseUrl}/poverty?state=${stateCode}`;
          break;
        case "economic":
          url = `${baseUrl}/economic?state=${stateCode}`;
          break;
        case "politicalincome":
          url = `${baseUrl}/politicalincome?state=${stateCode}`;
          break;
        default:
          return null;
      }

      try {
        const response = await axios.get(url);
        setHeatmapData(response.data);
        return response.data;
      } catch (error) {
        console.error(`Error fetching heatmap data: ${error}`);
        return null;
      }
    },
    []
  );

  const getHeatmapStyle = useCallback(
    (feature: any): L.PathOptions => {
      const defaultStyle: L.PathOptions = {
        color: "#000",
        weight: 0.5,
        fillOpacity: 0.8,
      };

      if (!feature.properties?.data) {
        return {
          ...defaultStyle,
          fillColor: "#FFFFFF",
        };
      }

      if (heatmapType === "none") {
        const isDemo =
          feature.properties?.["election data"]?.["bidenVotes"] >
          feature.properties?.["election data"]?.["trumpVotes"];
        return {
          ...defaultStyle,
          fillColor: isDemo ? "#0000FF" : "#FF5733",
        };
      }

      let fillColor;
      switch (heatmapType) {
        case "demographic":
          fillColor =
            feature.properties.data["demographic shading"] || "#FFFFFF";
          break;
        case "poverty":
          fillColor = feature.properties.data["poverty shading"] || "#FFFFFF";
          break;
        case "economic":
          fillColor = feature.properties.data["income shading"] || "#FFFFFF";
          break;
        case "politicalincome":
          fillColor =
            feature.properties.data["income_shading_by_party"] || "#FFFFFF";
          break;
        default:
          fillColor = "#FFFFFF";
      }

      return {
        ...defaultStyle,
        fillColor,
      };
    },
    [heatmapType]
  );

  const highlightFeatures = useCallback((e: L.LeafletMouseEvent) => {
    const layer = e.target as FeatureLayer;
    layer.setStyle({
      weight: 5,
      color: "#666",
      dashArray: "",
      fillOpacity: 0.7,
    });
  }, []);

  const resetHighlight = useCallback(
    (e: L.LeafletMouseEvent, geojson: L.GeoJSON) => {
      geojson.resetStyle(e.target);
    },
    []
  );

  const zoomToFeature = useCallback((e: L.LeafletMouseEvent, map: L.Map) => {
    map.fitBounds(e.target.getBounds());
  }, []);

  useEffect(() => {
    if (selectedDistrict && geoLayerRef.current) {
      geoLayerRef.current.eachLayer((layer: any) => {
        if (
          layer.feature &&
          Number(layer.feature.properties.geoId) === selectedDistrict
        ) {
          // Highlight the selected district
          layer.setStyle({
            weight: 5,
            color: "#666",
            dashArray: "",
            fillOpacity: 0.7,
          });
          const bounds = layer.getBounds();
          map?.fitBounds(bounds, { padding: [50, 50] }); // Adjust padding for better visibility
        } else if (layer.feature) {
          // Reset other layers' styles
          layer.setStyle({
            weight: 0.5,
            color: "#000",
            fillOpacity: 0.8,
          });
        }
      });
    } else if (!selectedDistrict && geoLayerRef.current) {
      // Reset styles when no district is selected
      geoLayerRef.current.eachLayer((layer: any) => {
        if (layer.feature) {
          layer.setStyle({
            weight: 0.5,
            color: "#000",
            fillOpacity: 0.8,
          });
        }
      });

      // if no district is selected zoom back out to the state level
      if (selectedState === "Arkansas") {
        map?.flyToBounds(
          new L.LatLngBounds(
            new L.LatLng(36.501861, -89.730812),
            new L.LatLng(33.002096, -94.616242)
          ),
          { duration: 1.5, easeLinearity: 0.25 }
        );
      } else if (selectedState === "New York") {
        map?.flyToBounds(
          new L.LatLngBounds(
            new L.LatLng(45.018503, -72.100541),
            new L.LatLng(40.543843, -79.76278)
          ),
          { duration: 1.5, easeLinearity: 0.25 }
        );
      } else {
        // Default to a region-level zoom if no specific state is selected
        map?.flyTo([37.8, -96], 4, {
          duration: 1.5,
          easeLinearity: 0.25,
        });
      }
    }
  }, [selectedDistrict, selectedState]);

  const handleCompare = useCallback(
    (planNumber: string) => {
      if (selectedState) {
        fetchDistrictPlan(selectedState, planNumber);
      }
    },
    [selectedState]
  );

  const onClick = useCallback(
    (e: L.LeafletMouseEvent, map: L.Map, feature: Feature) => {
      const stateName = feature.properties?.name || null;
      if (stateName === "New York" || stateName === "Arkansas") {
        onStateSelect(stateName);
        zoomToFeature(e, map);
      }
    },
    [onStateSelect, zoomToFeature]
  );

  const fetchMapData = useCallback(
    async (state: string, type: "DISTRICT" | "PRECINCT") => {
      try {
        const stateCode = state.toLowerCase().replace(" ", "");
        const response = await axios.get(
          `http://localhost:8080/api/map?state=${stateCode}&geoType=${type}`
        );

        if (response.data) {
          if (state === "Arkansas") {
            setArkansasData((prev) => ({
              ...prev,
              [type.toLowerCase()]: response.data,
            }));
          } else if (state === "New York") {
            setNewYorkData((prev) => ({
              ...prev,
              [type.toLowerCase()]: response.data,
            }));
          }
        }
      } catch (error) {
        console.error(
          `Error fetching ${type.toLowerCase()} data for ${state}:`,
          error
        );
      }
    },
    []
  );

  // Initialize the base map
  useEffect(() => {
    if (mapRef.current && !map) {
      const initialMap = L.map(mapRef.current, {
        zoomAnimation: true,
        fadeAnimation: true,
        markerZoomAnimation: true,
      }).setView([37.8, -96], 4);

      L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
        minZoom: 3,
        maxZoom: 24,
        attribution:
          '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
      }).addTo(initialMap);

      const onEachFeature = (feature: Feature, layer: L.Layer) => {
        layer.on({
          mouseover: highlightFeatures,
          mouseout: (e) => resetHighlight(e, geojson),
          click: (e) => onClick(e, initialMap, feature),
        });
      };

      const geojson = L.geoJSON(statesData as GeoJsonObject, {
        style: (feature) => ({
          fillColor:
            feature?.properties?.name === "New York"
              ? "#0000FF"
              : feature?.properties?.name === "Arkansas"
              ? "#FF5733"
              : "#FFFFFF",
          color: "#000",
          weight: 0.7,
          fillOpacity: 0.7,
        }),
        onEachFeature: onEachFeature,
      }).addTo(initialMap);

      setMap(initialMap);
    }
  }, [map, highlightFeatures, onClick, resetHighlight]);

  // Effect to fetch data when state or geoLevel changes
  useEffect(() => {
    if (selectedState === "Arkansas" || selectedState === "New York") {
      const stateData =
        selectedState === "Arkansas" ? arkansasData : newYorkData;

      if (!stateData[geoLevel]) {
        fetchMapData(
          selectedState,
          geoLevel.toUpperCase() as "DISTRICT" | "PRECINCT"
        );
      }
    }
  }, [selectedState, geoLevel, fetchMapData, arkansasData, newYorkData]);

  // Effect to handle heatmap updates
  useEffect(() => {
    if (selectedState && geoLevel === "precinct" && heatmapType !== "none") {
      fetchHeatmapData(selectedState, heatmapType, selectedDemographic);
    }
  }, [
    selectedState,
    geoLevel,
    heatmapType,
    selectedDemographic,
    fetchHeatmapData,
  ]);

  // Handle state selection and map updates
  useEffect(() => {
    if (!map) return;
    // Ensure map resizes correctly when container size changes
    if (map) {
      setTimeout(() => map.invalidateSize(), 1000) // This will make sure that the map recalculates its size after layout changes)
    }

    const fitToBound = (selectedState: string | null) => {
      map.invalidateSize();

      if (selectedState === "Arkansas") {
        map.flyToBounds(
          new L.LatLngBounds(
            new L.LatLng(36.501861, -89.730812),
            new L.LatLng(33.002096, -94.616242)
          ),
          {
            duration: 1.5,
            easeLinearity: 0.25,
          }
        );
      } else if (selectedState === "New York") {
        map.flyToBounds(
          new L.LatLngBounds(
            new L.LatLng(45.018503, -72.100541),
            new L.LatLng(40.543843, -79.76278)
          ),
          {
            duration: 1.5,
            easeLinearity: 0.25,
          }
        );
      } else {
        map.flyTo([37.8, -96], 4, {
          duration: 1.5,
          easeLinearity: 0.25,
        });
      }
    };

    fitToBound(selectedState);

    // Clear existing layer
    if (geoLayerRef.current) {
      map.removeLayer(geoLayerRef.current);
      geoLayerRef.current = null;
    }

    if (selectedState !== "State") {
      const stateData =
        selectedState === "Arkansas" ? arkansasData : newYorkData;
      const currentGeoData = stateData[geoLevel];

      if (currentGeoData) {
        const layerData =
          heatmapType !== "none" && heatmapData
            ? heatmapData
            : { type: "FeatureCollection", features: currentGeoData };

        const getLayerStyle = (feature: any) => {
          if (geoLevel === "district") {
            // Handle district plan comparison view
            if (districtPlanData) {
              const planFeature = districtPlanData.features.find(
                (f: any) => f.properties.number === feature.properties.number
              );
              return {
                fillColor: planFeature ? "#FFD700" : "#FFFFFF",
                color: "#000",
                weight: 0.5,
                fillOpacity: 0.8,
              };
            }
            // Default district style
            return {
              fillColor: "#FFFFFF",
              color: "#000",
              weight: 0.5,
              fillOpacity: 0.8,
            };
          }
          // Precinct style (heatmap)
          return getHeatmapStyle(feature);
        };

        geoLayerRef.current = L.geoJSON(layerData as GeoJsonObject, {
          style: getLayerStyle,
          onEachFeature: (feature, layer) => {
            layer.on({
              mouseover: highlightFeatures,
              mouseout: (e) => resetHighlight(e, geoLayerRef.current!),
            });
          },
        }).addTo(map);
      }
    }
  }, [
    map,
    selectedState,
    geoLevel,
    arkansasData,
    newYorkData,
    heatmapType,
    heatmapData,
    districtPlanData,
    highlightFeatures,
    resetHighlight,
    getHeatmapStyle,
  ]);

  const containerRef = useRef<HTMLDivElement>(null);
  const resizeObserverRef = useRef<ResizeObserver | null>(null);

  // Initialize resize observer
  useEffect(() => {
    if (!containerRef.current) return;

    const updateMapSize = () => {
      if (map) {
        map.invalidateSize();
      }
    };

    resizeObserverRef.current = new ResizeObserver((entries) => {
      for (const entry of entries) {
        if (entry.target === containerRef.current) {
          updateMapSize();
        }
      }
    });

    resizeObserverRef.current.observe(containerRef.current);

    return () => {
      if (resizeObserverRef.current) {
        resizeObserverRef.current.disconnect();
      }
    };
  }, [map]);

  // Add state legend component
  const StateLegend = () => (
    <Box
      position="absolute"
      bottom="20px"
      left="10px"
      bg="rgba(255, 255, 255, 0.9)"
      p={2}
      borderRadius="md"
      boxShadow="sm"
      zIndex={1000}
    >
      <Text fontSize="sm" fontWeight="medium" mb={1}>
        State Political Leaning
      </Text>
      <VStack align="start" spacing={1}>
        <Flex align="center" gap={2}>
          <Box w="12px" h="12px" bg="#0000FF" opacity={0.7} />
          <Text fontSize="xs">Democratic (New York)</Text>
        </Flex>
        <Flex align="center" gap={2}>
          <Box w="12px" h="12px" bg="#FF5733" opacity={0.7} />
          <Text fontSize="xs">Republican (Arkansas)</Text>
        </Flex>
      </VStack>
    </Box>
  );

  return (
    <Box
      ref={containerRef}
      position="relative"
      height="100%"
      flex={1}
      minHeight={selectedState !== "State" ? "0" : "400px"}
    >
      <Box
        id="map"
        ref={mapRef}
        position="absolute"
        top="0"
        left="0"
        right="0"
        bottom="0"
        borderRadius="lg"
        overflow="hidden"
        boxShadow="sm"
      />

      {/* Show state legend only when no state is selected */}
      {selectedState === "State" && <StateLegend />}

      {/* Existing legends and overlays */}
      {selectedState !== "State" && geoLevel === "precinct" && (
        <MapLegend
          heatmapType={heatmapType}
          selectedDemographic={selectedDemographic}
        />
      )}

      {districtPlanData && geoLevel === "district" && (
        <Box
          position="absolute"
          bottom="20px"
          left="10px"
          bg="rgba(255, 255, 255, 0.9)"
          p={2}
          borderRadius="md"
          boxShadow="sm"
          zIndex={1000}
        >
          <Text fontSize="sm" fontWeight="medium">
            District Plan Comparison
          </Text>
          <Flex mt={1} gap={3}>
            <Flex align="center" gap={2}>
              <Box w="12px" h="12px" bg="#FFD700" borderRadius="sm" />
              <Text fontSize="xs">Changed Districts</Text>
            </Flex>
            <Flex align="center" gap={2}>
              <Box
                w="12px"
                h="12px"
                bg="#FFFFFF"
                border="1px solid"
                borderColor="gray.300"
                borderRadius="sm"
              />
              <Text fontSize="xs">Unchanged Districts</Text>
            </Flex>
          </Flex>
        </Box>
      )}
    </Box>
  );
};

export default USMap;
